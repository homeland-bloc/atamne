<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Atamne</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 10px;
            margin: 0;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 20px;
            max-width: 100%;
            width: 100%;
            min-height: auto;
            overflow-x: auto;
        }

        @media (min-width: 768px) {
            body {
                padding: 20px;
            }
            
            .game-container {
                padding: 40px;
                max-width: 1200px;
                min-height: 800px;
            }
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 1.8em;
            background: linear-gradient(45deg, #ef5350, #ff8a65, #ffeb3b, #66bb6a, #42a5f5, #ab47bc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            .game-title {
                font-size: 2.5em;
            }
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            gap: 5px;
            flex-wrap: wrap;
        }

        .tab-button {
            background: linear-gradient(45deg, #e0e0e0, #f5f5f5);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            color: #666;
            font-size: 16px;
        }

        .tab-button.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.3);
        }

        .tab-button:hover:not(.active) {
            background: linear-gradient(45deg, #d0d0d0, #e5e5e5);
            transform: translateY(-1px);
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef5350, #ff8a65, #ffeb3b, #66bb6a, #42a5f5, #ab47bc);
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .fusion-table {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            margin-bottom: 20px;
            max-width: 100%;
            width: 100%;
            justify-items: center;
        }

        @media (min-width: 768px) {
            .fusion-table {
                gap: 12px;
                margin-bottom: 30px;
                max-width: 600px;
                margin-left: auto;
                margin-right: auto;
            }
        }

        .character-slot {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            height: 50px;
            width: 50px;
            background: #f8f9fa;
            flex-shrink: 0;
        }

        @media (min-width: 768px) {
            .character-slot {
                height: 72px;
                width: 72px;
                border: 3px solid #ddd;
                border-radius: 15px;
            }
        }

        .character-slot.unlocked {
            border-color: #4ecdc4;
            background: white;
        }

        .character-slot.unlocked:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .character-slot.selected {
            border-color: #ff6b6b;
            background: #fff5f5;
            transform: scale(1.05);
        }

        .character-slot.locked {
            background: #f0f0f0;
            border-color: #ccc;
            cursor: not-allowed;
        }

        .character-sprite {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .character-sprite {
                font-size: 24px;
            }
        }

        /* Single gene styling - gradient from gene color to white */
        .single-gene {
            background: linear-gradient(135deg, var(--gene-color), white);
            font-size: 20px;
        }

        @media (min-width: 768px) {
            .single-gene {
                font-size: 32px;
            }
        }

        /* Double gene styling - side by side emojis */
        .double-gene {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 2px;
            font-size: 12px;
        }

        .double-gene.same-gene {
            background: var(--same-gene-gradient);
        }

        .double-gene.different-genes {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
        }

        @media (min-width: 768px) {
            .double-gene {
                gap: 4px;
                font-size: 18px;
            }
        }

        .double-gene .gene-emoji {
            display: inline-block;
            line-height: 1;
        }

        .locked-sprite {
            background: #ccc;
            color: #999;
            font-size: 18px;
        }

        @media (min-width: 768px) {
            .locked-sprite {
                font-size: 28px;
            }
        }

        .reset-section {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .reset-button, .fuse-btn {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .fuse-btn {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 50px;
        }

        .reset-button:hover, .fuse-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.3);
        }

        .fuse-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .fuse-btn.fusion {
            animation: fusionPulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes fusionPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        .confirmation-popup {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .confirmation-popup.show {
            display: flex;
        }

        .confirmation-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px;
            margin: 20px;
        }

        .confirmation-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .confirm-btn, .cancel-btn {
            padding: 10px 25px;
            border: none;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .confirm-btn {
            background: #ff6b6b;
            color: white;
        }

        .confirm-btn:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }

        .cancel-btn {
            background: #e0e0e0;
            color: #666;
        }

        .cancel-btn:hover {
            background: #d0d0d0;
            transform: translateY(-2px);
        }

        .game-header-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            .game-header-controls {
                justify-content: center;
                gap: 30px;
            }
        }

        .progress-section {
            flex: 1;
            min-width: 200px;
            max-width: 400px;
        }

        .character-sprite::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3));
            z-index: -1;
        }

        .fusion-controls {
            text-align: center;
            margin-bottom: 20px;
        }

        .fusion-preview {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: none;
            overflow: hidden;
        }

        .fusion-preview.show {
            display: block;
            animation: fusionPreviewPop 0.3s ease-out;
        }

        @keyframes fusionPreviewPop {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .preview-character {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin: 0 auto;
            transition: all 0.2s ease;
            position: relative;
        }

        @media (min-width: 768px) {
            .preview-character {
                width: 100px;
                height: 100px;
                font-size: 36px;
            }
        }

        .preview-character.single-gene {
            background: linear-gradient(135deg, var(--gene-color), white);
        }

        .preview-character.double-gene {
            display: flex;
            flex-direction: row;
            gap: 4px;
            font-size: 20px;
        }

        .preview-character.double-gene.same-gene {
            background: var(--same-gene-gradient);
        }

        .preview-character.double-gene.different-genes {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
        }

        @media (min-width: 768px) {
            .preview-character.double-gene {
                gap: 6px;
                font-size: 28px;
            }
        }

        .sunshine-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.8) 0%, rgba(255, 215, 0, 0.4) 30%, transparent 70%);
            border-radius: 50%;
            animation: sunshineGlow 1s ease-out;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes sunshineGlow {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        }

        .fusion-sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
        }

        .bot-control {
            text-align: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            border: 2px solid #e0e0e0;
        }

        @media (min-width: 768px) {
            .bot-control {
                margin-bottom: 20px;
                padding: 15px;
            }
        }

        .bot-switch {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-weight: bold;
            color: #666;
            font-size: 14px;
            flex-wrap: wrap;
        }

        @media (min-width: 768px) {
            .bot-switch {
                gap: 15px;
                font-size: 16px;
            }
        }

        .control-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #666;
        }

        .speed-options {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .speed-option {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #666;
        }

        .speed-radio {
            width: 18px;
            height: 18px;
            border: 2px solid #ccc;
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .speed-radio.active {
            border-color: #4ecdc4;
            background: #4ecdc4;
        }

        .speed-radio.active::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .bot-status {
            margin-top: 10px;
            font-size: 14px;
            color: #999;
        }

        .bot-status.active {
            color: #4ecdc4;
            font-weight: bold;
        }

        .selection-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }

        .selected-character {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
        }

        .game-stats {
            text-align: center;
            color: #666;
            font-size: 16px;
        }

        .victory-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            z-index: 1000;
            display: none;
        }

        .victory-message.show {
            display: block;
            animation: victoryPop 0.6s ease-out;
        }

        @keyframes victoryPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .gene-labels {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            margin-bottom: 8px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            justify-items: center;
        }

        @media (min-width: 768px) {
            .gene-labels {
                gap: 12px;
                margin-bottom: 10px;
                font-size: 12px;
                max-width: 600px;
                margin-left: auto;
                margin-right: auto;
            }
        }

        .gene-label {
            padding: 3px;
            border-radius: 8px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 25px;
            width: 50px;
        }

        @media (min-width: 768px) {
            .gene-label {
                padding: 5px;
                height: 30px;
                width: 72px;
            }
        }

        @keyframes newDiscovery {
            0% { transform: scale(0) rotate(0deg); }
            50% { transform: scale(1.2) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }

        .new-discovery {
            animation: newDiscovery 0.8s ease-out;
        }

        /* BATTLE ARENA STYLES */
        .battle-arena {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-height: 600px;
        }

        .turn-order-bar {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 2px solid #e0e0e0;
        }

        .turn-order-title {
            text-align: center;
            font-weight: bold;
            color: #666;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .turn-order-list {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .turn-indicator {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            background: white;
            transition: all 0.3s ease;
            position: relative;
        }

        .turn-indicator.active {
            border-color: #4ecdc4;
            background: #4ecdc4;
            color: white;
            transform: scale(1.2);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .turn-indicator.player {
            border-color: #42a5f5;
        }

        .turn-indicator.enemy {
            border-color: #ff6b6b;
        }

        .battle-field {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            min-height: 400px;
        }

        @media (max-width: 768px) {
            .battle-field {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .team-section {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .team-section.player-team {
            border-color: #42a5f5;
        }

        .team-section.enemy-team {
            border-color: #ff6b6b;
        }

        .team-title {
            text-align: center;
            font-weight: bold;
            color: #666;
            font-size: 18px;
            margin-bottom: 10px;
        }

        .team-title.player {
            color: #42a5f5;
        }

        .team-title.enemy {
            color: #ff6b6b;
        }

        .character-selection-panel {
            background: rgba(240, 240, 240, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #ddd;
            max-height: 200px;
            overflow-y: auto;
        }

        .random-select-btn {
            background: linear-gradient(45deg, #9c27b0, #673ab7);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            width: 100%;
        }

        .random-select-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.3);
        }

        .selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            justify-items: center;
        }

        @media (min-width: 768px) {
            .selection-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            }
        }

        .selection-slot {
            width: 60px;
            height: 60px;
            border: 2px solid #ddd;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (min-width: 768px) {
            .selection-slot {
                width: 80px;
                height: 80px;
            }
        }

        .selection-slot:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        .selection-slot.selected {
            border-color: #4ecdc4;
            background: #f0ffff;
        }

        .battle-team-display {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .battle-character {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 10px;
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .battle-character.active {
            background: rgba(78, 205, 196, 0.1);
            border: 2px solid #4ecdc4;
        }

        .battle-character.defeated {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        .battle-sprite {
            width: 80px;  /* Changed from 60px */
            height: 80px;  /* Changed from 60px */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;  /* Changed from 20px */
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            border: 2px solid #ddd;
            background: white;
        }

        @media (min-width: 768px) {
            .battle-sprite {
                width: 100px;  /* Changed from 80px */
                height: 100px;  /* Changed from 80px */
                font-size: 32px;  /* Changed from 28px */
            }
        }

        .character-stats {
            text-align: center;
            font-size: 12px;
            color: #666;
        }

        .health-bar {
            width: 60px;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }

        @media (min-width: 768px) {
            .health-bar {
                width: 80px;
                height: 8px;
            }
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ffeb3b, #66bb6a);
            transition: width 0.5s ease;
            border-radius: 3px;
        }

        .battle-controls {
            position: sticky;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            text-align: center;
        }

        .attack-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .attack-btn {
            background: linear-gradient(45deg, var(--attack-color, #4ecdc4), var(--attack-color-light, #44a08d));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            min-width: 100px;  /* Changed to match target buttons */
            max-width: 120px;  /* Added to match target buttons */
            flex: 1 1 100px;   /* Added to match target buttons */
            position: relative;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .attack-btn {
                padding: 15px 30px;
                font-size: 16px;
                min-width: 120px;
            }
        }

        .attack-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .attack-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .attack-btn .effectiveness {
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
        }

        .attack-btn .effectiveness.super-effective {
            background: #66bb6a;
            color: white;
        }

        .attack-btn .effectiveness.not-very-effective {
            background: #ff6b6b;
            color: white;
        }

        .battle-log {
            background: rgba(240, 240, 240, 0.8);
            border-radius: 10px;
            padding: 15px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 14px;
            color: #666;
            border: 1px solid #ddd;
            margin-top: 15px;
        }

            .battle-log-modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                z-index: 2000;
                display: none;
                align-items: center;
                justify-content: center;
                padding: 20px;
            }

            .battle-log-modal.show {
                display: flex;
            }

            .battle-log-modal-content {
                background: white;
                border-radius: 20px;
                padding: 20px;
                width: 100%;
                max-width: 500px;
                max-height: 85vh;
                display: flex;
                flex-direction: column;
            }

            .battle-log-modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 2px solid #e0e0e0;
            }

            .battle-log-modal-close {
                background: #ff6b6b;
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 15px;
                cursor: pointer;
                font-weight: bold;
            }

            .battle-log-modal-content .battle-log {
                display: block !important;
                flex: 1;
                overflow-y: auto;
                background: #f8f9fa;
                border-radius: 10px;
                padding: 15px;
                font-size: 14px;
                color: #666;
                border: 1px solid #ddd;
                margin: 0;
                min-height: 400px;
            }

            @media (max-width: 768px) {
                .battle-log-button {
                    display: block;
                }
                
                .battle-log {
                    display: none !important;
                }
            }

        .log-entry {
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }

        .log-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .log-entry.damage {
            color: #ff6b6b;
        }

        .log-entry.super-effective {
            color: #66bb6a;
            font-weight: bold;
        }

        .log-entry.not-very-effective {
            color: #ff8a65;
        }

        .damage-number {
            position: absolute;
            font-size: 28px;
            font-weight: 900;
            color: #ff6b6b;
            z-index: 100;
            pointer-events: none;
            text-shadow: 
                2px 2px 0px #000,
                -2px -2px 0px #000,
                2px -2px 0px #000,
                -2px 2px 0px #000,
                0px 2px 4px rgba(0, 0, 0, 0.8);
            font-family: 'Arial Black', Arial, sans-serif;
            letter-spacing: 1px;
        }

        .damage-number.super-effective {
            color: #66bb6a;
            font-size: 36px;
            text-shadow: 
                2px 2px 0px #2e7d32,
                -2px -2px 0px #2e7d32,
                2px -2px 0px #2e7d32,
                -2px 2px 0px #2e7d32,
                0px 3px 6px rgba(46, 125, 50, 0.8);
        }

        .damage-number.not-very-effective {
            color: #ff8a65;
            font-size: 20px;
            text-shadow: 
                1px 1px 0px #e65100,
                -1px -1px 0px #e65100,
                1px -1px 0px #e65100,
                -1px 1px 0px #e65100,
                0px 2px 4px rgba(230, 81, 0, 0.6);
        }

        @keyframes damageFloat {
            0% {
                transform: translateY(0) scale(0.8);
                opacity: 0;
            }
            15% {
                transform: translateY(-10px) scale(1.1);
                opacity: 1;
            }
            85% {
                transform: translateY(-80px) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-120px) scale(0.9);
                opacity: 0;
            }
        }

        .damage-animation {
            animation: damageFloat 2.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        @keyframes battleShake {
            0%, 100% { 
                transform: translateX(0); 
            }
            10% { 
                transform: translateX(calc(-8px * var(--shake-intensity, 1))); 
            }
            20% { 
                transform: translateX(calc(8px * var(--shake-intensity, 1))); 
            }
            30% { 
                transform: translateX(calc(-6px * var(--shake-intensity, 1))); 
            }
            40% { 
                transform: translateX(calc(6px * var(--shake-intensity, 1))); 
            }
            50% { 
                transform: translateX(calc(-4px * var(--shake-intensity, 1))); 
            }
            60% { 
                transform: translateX(calc(4px * var(--shake-intensity, 1))); 
            }
            70% { 
                transform: translateX(calc(-2px * var(--shake-intensity, 1))); 
            }
            80% { 
                transform: translateX(calc(2px * var(--shake-intensity, 1))); 
            }
        }

        .battle-shake {
            animation: battleShake 0.5s ease-in-out;
        }

        .team-setup {
            text-align: center;
            padding: 20px;
        }

        .setup-instructions {
            margin-bottom: 20px;
            font-size: 16px;
            color: #666;
        }

        .start-battle-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .start-battle-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .start-battle-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .selected-team-display {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            border: 2px solid #e0e0e0;
        }

        .selected-team-title {
            font-weight: bold;
            color: #666;
            margin-bottom: 15px;
            text-align: center;
        }

        .selected-team-grid {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            /* Add safe area for device navigation */
            body {
                padding-bottom: env(safe-area-inset-bottom, 20px) !important;
            }
            
            /* Slightly smaller header to save some space */
            .game-title {
                font-size: 1.4em !important;
                margin-bottom: 10px !important;
            }
            
            .tab-navigation {
                margin-bottom: 15px !important;
            }
            
            /* Compact turn order */
            .turn-order-bar {
                padding: 8px !important;
                margin-bottom: 8px;
            }
            
            .turn-order-title {
                font-size: 12px !important;
                margin-bottom: 5px !important;
            }
            
            .turn-order-list {
                gap: 4px !important;
            }
            
            .turn-indicator {
                width: 32px !important;
                height: 32px !important;
                font-size: 10px !important;
            }
            
            /* Single column battle field */
            .battle-field {
                grid-template-columns: 1fr !important;
                gap: 10px !important;
            }
            
            /* Remove excessive padding/margins from team sections */
            .team-section {
                padding: 12px !important;
                min-height: auto !important;
                margin-bottom: 0 !important;
            }
            
            .team-title {
                font-size: 16px !important;
                margin-bottom: 10px !important;
            }
            
            /* Larger, more readable characters */
            .battle-character {
                padding: 8px !important;
                gap: 5px !important;
                min-width: 110px;
                max-width: 120px;
            }
            
            .battle-sprite {
                width: 50px !important;
                height: 50px !important;
                font-size: 18px !important;
            }
            
            .character-stats {
                font-size: 12px !important;
                line-height: 1.2 !important;
            }
            
            .character-stats div {
                margin-bottom: 2px !important;
            }
            
            .health-bar {
                width: 50px !important;
                height: 5px !important;
                margin-top: 4px !important;
            }
            
            .battle-team-display {
                gap: 10px !important;
                justify-content: space-around;
                flex-wrap: nowrap;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            /* REMOVE WASTED SPACE - tight battle arena */
            .battle-arena {
                padding-bottom: 140px !important;
                gap: 10px !important;  /* Changed from gap: 5px */
                padding-top: 0 !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: flex-start !important;
                min-height: calc(100vh - 200px) !important;
            }
            
            /* Remove extra space around team sections */
            .team-section.player-team {
                margin-bottom: 5px !important;
            }
            
            .team-section.enemy-team {
                margin-bottom: 5px !important;
                flex-grow: 0 !important; /* Don't let it expand */
            }
            
            /* IMPROVED battle controls positioning and sizing */
            .battle-controls {
                padding: 15px !important;
                position: fixed !important;
                bottom: 20px !important;
                left: 10px !important;
                right: 10px !important;
                background: rgba(255, 255, 255, 0.98) !important;
                border-radius: 20px !important;
                max-height: 450px !important; /* Increased from 300px by 1.5x */
                overflow-y: auto !important;
                z-index: 1000 !important;
                box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
                margin-bottom: max(30px, env(safe-area-inset-bottom, 30px)) !important;
            }
            
            /* Larger controls header */
            .battle-controls > div:first-child {
                margin-bottom: 12px !important;
                font-size: 16px !important;
                font-weight: bold !important;
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 10px;
            }
            
            /* Style both quit and log buttons similarly */
            #quitBattleBtn, #battleLogButton {
                padding: 8px 12px !important;
                font-size: 12px !important;
                min-width: auto !important;
                border-radius: 12px !important;
                white-space: nowrap;
            }

            .battle-log-button {
                display: inline-block !important;
                position: static !important;
                background: linear-gradient(45deg, #4ecdc4, #44a08d) !important;
                color: white !important;
                border: none !important;
                padding: 8px 12px !important;
                font-size: 12px !important;
                min-width: auto !important;
                border-radius: 12px !important;
                font-weight: bold !important;
                cursor: pointer !important;
                box-shadow: none !important;
                margin: 0 0 0 8px !important;
                white-space: nowrap !important;
            }
                        
            /* "Select an attack:" text */
            .attack-buttons > div:first-child {
                font-size: 15px !important;
                margin-bottom: 10px !important;
                font-weight: 500 !important;
            }
            
            /* IMPROVED attack buttons layout */
            .attack-buttons {
                flex-direction: row !important;
                gap: 8px !important; /* Reduced gap for better fit */
                justify-content: center;
                flex-wrap: wrap;
                margin-bottom: 0;
            }
            
            .attack-btn {
                min-width: 130px !important; /* Smaller for better fit */
                max-width: 150px !important; /* Prevent buttons from getting too wide */
                padding: 12px 16px !important; /* Smaller padding */
                font-size: 14px !important; /* Smaller font */
                font-weight: bold !important;
                border-radius: 16px !important;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                flex: 1 1 auto !important; /* Allow flexible sizing */
            }
            
            /* Hide battle log on mobile */
            .battle-log {
                display: none !important;
            }
            
            /* Container adjustments */
            .game-container {
                padding: 8px !important;
                padding-bottom: 100px !important; /* Increased safe area at bottom */
                min-height: 100vh;
                display: flex;
                flex-direction: column;
            }
            
            /* Make turn order more compact on mobile */
            .turn-order-bar {
                padding: 10px !important;
                margin-bottom: 5px !important;
            }
            
            .turn-order-title {
                font-size: 12px !important;
                margin-bottom: 8px !important;
            }
            
            .turn-indicator {
                width: 35px !important;
                height: 35px !important;
                font-size: 11px !important;
            }
            
            /* Remove any flex-grow that might cause spacing issues */
            .tab-content {
                flex-grow: 0 !important;
            }
            
            /* Ensure battle arena has proper spacing */
            .battle-arena {
                padding-bottom: 120px !important; /* Space for controls */
            }
            
            /* Improve button touch targets */
            .attack-btn {
                min-height: 44px !important; /* iOS minimum touch target */
            }
            
            /* Better spacing for attack selection text */
            .attack-buttons > div:first-child {
                margin-bottom: 12px !important;
                padding: 0 10px !important;
            }
            
            .log-entry.player-attack {
                color: #2e7d32;
                font-weight: bold;
            }

            .log-entry.enemy-attack {
                color: #c62828;
                font-weight: bold;
            }

            .log-entry.player-attack.super-effective {
                color: #1b5e20;
                background: rgba(76, 175, 80, 0.1);
                border-left: 3px solid #4caf50;
                padding-left: 8px;
            }

            .log-entry.enemy-attack.super-effective {
                color: #b71c1c;
                background: rgba(244, 67, 54, 0.1);
                border-left: 3px solid #f44336;
                padding-left: 8px;
            }

            .log-entry.player-attack.not-very-effective {
                color: #388e3c;
                opacity: 0.8;
            }

            .log-entry.enemy-attack.not-very-effective {
                color: #d32f2f;
                opacity: 0.8;
            }
            
            /* FIXED target selection button layout - ensure all 3 buttons fit */
            .attack-buttons .attack-btn[style*="background"] {
                min-width: 100px !important; /* Smaller for target buttons */
                max-width: 120px !important;
                padding: 10px 12px !important;
                font-size: 12px !important;
                margin: 2px !important;
                flex: 1 1 100px !important; /* Fixed basis for consistent sizing */
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
            }
            
            /* Ensure target container fits properly with all 3 buttons */
            .attack-buttons > div:last-child {
                display: flex !important;
                gap: 6px !important; /* Reduced gap */
                justify-content: center !important;
                flex-wrap: wrap !important;
                width: 100% !important;
                max-width: 100% !important;
                padding: 0 5px !important; /* Add small padding for edge spacing */
            }
            
            /* Additional responsive adjustments for very small screens */
            @media (max-width: 360px) {
                .attack-buttons .attack-btn[style*="background"] {
                    min-width: 90px !important;
                    max-width: 110px !important;
                    padding: 8px 10px !important;
                    font-size: 11px !important;
                    flex: 1 1 90px !important;
                }
                
                .attack-buttons > div:last-child {
                    gap: 4px !important;
                }
            }
            
            /* Mobile-optimized damage numbers with effectiveness indicators */
            .damage-number {
                font-size: 24px !important;
                max-width: 200px !important;
                text-align: center !important;
                word-wrap: break-word !important;
                line-height: 1.2 !important;
                padding: 2px 4px !important;
                border-radius: 8px !important;
                background: rgba(0, 0, 0, 0.7) !important;
                backdrop-filter: blur(4px) !important;
            }
            
            .damage-number.super-effective {
                font-size: 28px !important;
                background: rgba(46, 125, 50, 0.8) !important;
            }
            
            .damage-number.not-very-effective {
                font-size: 20px !important;
                background: rgba(230, 81, 0, 0.8) !important;
            }
        }

        .difficulty-btn {
            padding: 10px 20px;
            border: 2px solid #ddd;
            background: white;
            color: #666;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .difficulty-btn:hover:not(.active) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-color: #999;
        }

        .difficulty-btn.active {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            border-width: 3px;
        }

        /* Inactive state - all buttons have subtle gradient */
        .difficulty-btn[data-difficulty="easy"] {
            background: #f9f9f9;
            border-color: #e0e0e0;
        }

        .difficulty-btn[data-difficulty="normal"] {
            background: #f5f5f5;
            border-color: #d0d0d0;
        }

        .difficulty-btn[data-difficulty="hard"] {
            background: #eeeeee;
            border-color: #bdbdbd;
        }

        .difficulty-btn[data-difficulty="extreme"] {
            background: #e0e0e0;
            border-color: #9e9e9e;
        }

        /* Active state - strong visual indicator */ 
        .difficulty-btn[data-difficulty="easy"].active {
            background: linear-gradient(135deg, #ffffff, #f0f0f0);
            border-color: #4caf50;
            color: #2e7d32;
            position: relative;
        }

        .difficulty-btn[data-difficulty="normal"].active {
            background: linear-gradient(135deg, #e8e8e8, #d0d0d0);
            border-color: #ff9800;
            color: #424242;
        }

        .difficulty-btn[data-difficulty="hard"].active {
            background: linear-gradient(135deg, #9e9e9e, #757575);
            border-color: #ff5722;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .difficulty-btn[data-difficulty="extreme"].active {
            background: linear-gradient(135deg, #424242, #212121);
            border-color: #d32f2f;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* Add a glow effect for active buttons */
        .difficulty-btn.active::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: inherit;
            border-radius: 20px;
            opacity: 0.3;
            z-index: -1;
            filter: blur(8px);
        }

        /* Make the small text more visible */
        .difficulty-btn small {
            display: block;
            font-size: 10px;
            opacity: 0.8;
            margin-top: 2px;
        }

        .difficulty-btn.active small {
            opacity: 1;
            font-weight: normal;
        }

        @keyframes slideLeft {
            0% { transform: translateX(50px); opacity: 0.7; }
            100% { transform: translateX(0); opacity: 1; }
        }

        .turn-order-list {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            transition: all 0.3s ease;
        }

        .turn-indicator {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            background: white;
            transition: all 0.3s ease;
            position: relative;
        }

        .turn-indicator.active {
            border-color: #4ecdc4;
            background: #4ecdc4;
            color: white;
            transform: scale(1.2);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1.2); }
            50% { transform: scale(1.3); }
        }

        .battle-sprite.single-gene {
            background: linear-gradient(135deg, var(--gene-color), white) !important;
        }

        .animation-speed-control {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #4ecdc4;
            border-radius: 25px;
            padding: 10px 15px;
            display: none;
            gap: 10px;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .animation-speed-control.show {
            display: flex;
        }

        .speed-btn {
            background: #e0e0e0;
            border: none;
            padding: 8px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .speed-btn.active {
            background: #4ecdc4;
            color: white;
        }

        @media (max-width: 768px) {
            .animation-speed-control {
                top: 10px;
                right: 10px;
                padding: 8px 12px;
            }
            
            .speed-btn {
                padding: 6px 10px;
                font-size: 11px;
            }
        }

        .character-info-popup {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }

        .character-info-popup.show {
            display: flex;
        }

        .character-info-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .info-close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            background: #ff6b6b;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .info-character-display {
            text-align: center;
            margin-bottom: 20px;
        }

        .info-character-sprite {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin: 0 auto 15px auto;
            border: 3px solid #ddd;
        }

        .info-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .info-stat-card {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            color: white;
        }

        .info-stat-card.hp {
            background: linear-gradient(135deg, #ffca28, #ffc107);
        }

        .info-stat-card.atk {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
        }

        .info-stat-card.spd {
            background: linear-gradient(135deg, #42a5f5, #90caf9);
        }

        .info-attacks {
            margin-bottom: 20px;
        }

        .info-effectiveness {
            font-size: 14px;
        }

        .effectiveness-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .effectiveness-cell {
            text-align: center;
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
        }

        .effectiveness-cell.super {
            background: #66bb6a;
            color: white;
        }

        .effectiveness-cell.effective {
            background: #81c784;
            color: white;
        }

        .effectiveness-cell.normal {
            background: #e0e0e0;
            color: #333;
        }

        .effectiveness-cell.weak {
            background: #ffab91;
            color: #333;
        }

        .effectiveness-cell.very-weak {
            background: #ff8a65;
            color: white;
        }

        @media (max-width: 768px) {
            .character-info-content {
                margin: 10px;
                padding: 20px;
            }
            
            .info-stats-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .effectiveness-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        /* Fix attack button container alignment */
        #attackRow, #targetRow {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            flex-wrap: wrap !important;
            width: 100% !important;
            margin: 0 auto !important;
        }

        #attackRow .attack-btn, #targetRow .attack-btn {
            flex: 0 1 auto !important;
            min-width: 120px !important;
            max-width: 150px !important;
            margin: 4px !important;
        }

        @media (max-width: 768px) {
            #attackRow .attack-btn, #targetRow .attack-btn {
                min-width: 100px !important;
                max-width: 130px !important;
                margin: 2px !important;
            }
        }

        /* Enhanced glow effect for selected attack buttons */
        .attack-btn.selected-attack {
            box-shadow: 0 0 20px var(--attack-color), 0 0 40px var(--attack-color) !important;
            transform: scale(1.08) !important;
            border: 3px solid var(--attack-color) !important;
            filter: brightness(1.1) !important;
            z-index: 10 !important;
            position: relative !important;
        }

        .attack-btn.selected-attack::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: var(--attack-color);
            opacity: 0.3;
            border-radius: inherit;
            z-index: -1;
            filter: blur(10px);
        }

        /* Fix attack button container alignment - use specific selectors to avoid conflicts */
        .battle-controls #attackRow, 
        .battle-controls #targetRow {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            width: 100%;
            margin: 0 auto;
            gap: 8px;
        }

        .battle-controls #attackRow .attack-btn, 
        .battle-controls #targetRow .attack-btn {
            flex: 0 1 auto;
            min-width: min(120px, calc(50vw - 20px));
            max-width: 150px;
            margin: 2px;
        }

        /* Enhanced glow effect for selected attack buttons with fallbacks */
        .attack-btn.selected-attack {
            box-shadow: 
                0 0 20px var(--attack-color, #4ecdc4), 
                0 0 40px var(--attack-color, #4ecdc4),
                0 0 60px var(--attack-color, #4ecdc4) !important;
            transform: scale(1.05) !important;
            border: 3px solid var(--attack-color, #4ecdc4) !important;
            filter: brightness(1.1) !important;
            position: relative !important;
            z-index: 5 !important;
        }

        .attack-btn.selected-attack::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: var(--attack-color, #4ecdc4);
            opacity: 0.2;
            border-radius: inherit;
            z-index: -1;
            filter: blur(8px);
        }

        /* Ensure attack buttons don't interfere with higher z-index elements */
        .battle-controls {
            z-index: 1000 !important;
        }

        @media (max-width: 768px) {
            .battle-controls #attackRow, 
            .battle-controls #targetRow {
                gap: 6px;
            }
            
            .battle-controls #attackRow .attack-btn, 
            .battle-controls #targetRow .attack-btn {
                min-width: min(100px, calc(33vw - 10px));
                max-width: 130px;
                font-size: 12px;
                padding: 10px 8px;
            }
        }

        @media (max-width: 768px) {
            /* Only show team-setup when not in battle */
            body:not(.battle-active) .team-setup {
                display: block !important;
            }
            
            /* Hide team-setup during battle */
            body.battle-active .team-setup {
                display: none !important;
            }

            
            /* Additional rule to hide battle controls when not in battle */
            body:not(.battle-active) .battle-controls,
            body:not(.battle-active) .turn-order-bar,
            body:not(.battle-active) .battle-field {
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">Genetic Fusion & Battle Simulator</h1>
            
            <div class="tab-navigation">
                <button class="tab-button active" data-tab="fusion">🧬 Fusion Lab</button>
                <button class="tab-button" data-tab="battle">⚔️ Battle Arena</button>
            </div>
        </div>

        <div class="animation-speed-control" id="animationSpeedControl">
            <span style="font-size: 12px; color: #666; font-weight: bold;">Speed:</span>
            <button class="speed-btn active" data-speed="1">1x</button>
            <button class="speed-btn" data-speed="2">2x</button>
            <button class="speed-btn" data-speed="4">4x</button>
        </div>

        <!-- Fusion TAB -->
        <div class="tab-content active" id="fusion-tab">
            <div class="game-header-controls">
                <div class="progress-section">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="game-stats">
                        <span id="unlockedCount">6</span> / 42 creatures discovered
                    </div>
                </div>
            </div>

            <div class="gene-labels">
                <div class="gene-label" style="background: #ef5350;">Red</div>
                <div class="gene-label" style="background: #ff8a65;">Orange</div>
                <div class="gene-label" style="background: #ffeb3b;">Yellow</div>
                <div class="gene-label" style="background: #66bb6a;">Green</div>
                <div class="gene-label" style="background: #42a5f5;">Blue</div>
                <div class="gene-label" style="background: #ab47bc;">Purple</div>
                <div class="gene-label" style="background: #666;">Singles</div>
            </div>

            <div class="fusion-table" id="fusionTable"></div>

            <div class="bot-control">
                <div class="control-row">
                    <div class="bot-switch">
                        <span>Manual</span>
                        <label class="switch">
                            <input type="checkbox" id="botToggle">
                            <span class="slider"></span>
                        </label>
                        <span>Bot Solver</span>
                    </div>
                    <div class="speed-control">
                        <div class="speed-options">
                            <div class="speed-option">
                                <div class="speed-radio active" data-speed="1"></div>
                                <span>1x</span>
                            </div>
                            <div class="speed-option">
                                <div class="speed-radio" data-speed="2"></div>
                                <span>2x</span>
                            </div>
                            <div class="speed-option">
                                <div class="speed-radio" data-speed="4"></div>
                                <span>4x</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="bot-status" id="botStatus">Bot is off - You're in control</div>
            </div>

            <div class="selection-display">
                <div class="selected-character">
                    <div>Parent 1</div>
                    <div class="character-slot" id="parent1Display">
                        <div class="character-sprite locked-sprite">?</div>
                    </div>
                </div>
                <div style="font-size: 24px; color: #666;">+</div>
                <div class="selected-character">
                    <div>Parent 2</div>
                    <div class="character-slot" id="parent2Display">
                        <div class="character-sprite locked-sprite">?</div>
                    </div>
                </div>
            </div>

            <div class="fusion-controls">
                <button class="fuse-btn" id="fuseBtn" disabled>Select Two Creatures to Fuse</button>
            </div>

            <div class="reset-section">
                <button class="reset-button" id="resetButton">🔄 Reset Game</button>
                <button class="reset-button" id="unlockAllBtn" style="background: linear-gradient(45deg, #4ecdc4, #44a08d); margin-right: 15px;">🔓 Unlock All Characters</button>
            </div>
        </div>

        <!-- BATTLE TAB -->
        <div class="tab-content" id="battle-tab">
            <div id="team-setup" class="team-setup">
                <div class="setup-instructions">
                    <h3 style="color: #666; margin-bottom: 15px;">Choose Your Battle Team</h3>
                    <p>Select 3 creatures from your unlocked collection to form your battle team!</p>
                </div>

                <div class="character-selection-panel">
                    <button class="random-select-btn" id="randomSelectBtn">🎲 Select 3 Random Characters</button>
                    <div class="selection-grid" id="battleCharacterSelection"></div>
                </div>

                <div class="selected-team-display">
                    <div class="selected-team-title">Your Team (Select 3)</div>
                    <div class="selected-team-grid" id="selectedTeamDisplay"></div>
                </div>

                <div class="difficulty-selection" style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.8); border-radius: 15px; border: 2px solid #e0e0e0;">
                <div style="font-weight: bold; color: #666; margin-bottom: 15px; text-align: center;">Enemy AI Difficulty</div>
                <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                    <button class="difficulty-btn active" data-difficulty="easy">
                        🎆 Easy<small>Random moves</small>
                    </button>
                    <button class="difficulty-btn" data-difficulty="normal">
                        🧨 Normal<small>Semi-smart</small>
                    </button>
                    <button class="difficulty-btn" data-difficulty="hard">
                        🚒 Hard<small>Strategic</small>
                    </button>
                    <button class="difficulty-btn" data-difficulty="extreme">
                        💀 Extreme<small>Perfect play</small>
                    </button>
                </div>
            </div>

                <button class="start-battle-btn" id="startBattleBtn" disabled>Select 3 Creatures to Start Battle</button>
            </div>

            <div id="battle-arena" class="battle-arena" style="display: none;">
                <div class="turn-order-bar">
                    <div class="turn-order-title">Turn Order</div>
                    <div class="turn-order-list" id="turnOrderList"></div>
                </div>

                <div class="battle-field">
                    <div class="team-section player-team">
                        <div class="team-title player">Your Team</div>
                        <div class="battle-team-display" id="playerTeamDisplay"></div>
                    </div>

                    <div class="team-section enemy-team">
                        <div class="team-title enemy">Enemy Team</div>
                        <div class="battle-team-display" id="enemyTeamDisplay"></div>
                    </div>
                </div>

                <div class="battle-controls" id="battleControls">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="font-weight: bold; color: #666;">
                        <span id="activeCharacterName">Character</span>'s Turn
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button class="battle-log-button" id="battleLogButton">📜 Logs</button>
                        <button class="cancel-btn" id="quitBattleBtn" style="padding: 8px 12px; font-size: 12px;">Quit</button>
                    </div>
                </div>
                <div class="attack-buttons" id="attackButtons"></div>
                <div class="battle-log" id="battleLog"></div>
            </div>

                <div class="battle-log-modal" id="battleLogModal">
                    <div class="battle-log-modal-content">
                        <div class="battle-log-modal-header">
                            <h3 style="margin: 0; color: #666;">Battle Log</h3>
                            <button class="battle-log-modal-close" id="battleLogModalClose">✕ Close</button>
                        </div>
                        <div class="battle-log" id="battleLogModalContent"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Popups and Effects -->
    <div class="confirmation-popup" id="confirmationPopup">
        <div class="confirmation-content">
            <h3 style="color: #666; margin-bottom: 15px;">Reset Game?</h3>
            <p style="color: #888; margin-bottom: 20px;">This will clear all your progress and discoveries. Are you sure?</p>
            <div class="confirmation-buttons">
                <button class="confirm-btn" id="confirmReset">Yes, Reset</button>
                <button class="cancel-btn" id="cancelReset">Cancel</button>
            </div>
        </div>
    </div>

    <div class="fusion-preview" id="fusionPreview">
        <h3 style="text-align: center; margin-bottom: 20px; color: #666;">Fusion...</h3>
        <div class="preview-character" id="previewCharacter">?</div>
    </div>

    <div class="victory-message" id="victoryMessage">
        <h2 style="color: #4ecdc4; margin-bottom: 20px;">🎉 Congratulations! 🎉</h2>
        <p style="font-size: 18px; color: #666;">You've discovered all 42 gene combinations!</p>
        <p style="margin-top: 10px; color: #999;">Fusion master achievement unlocked!</p>
    </div>

    <div class="character-info-popup" id="characterInfoPopup">
        <div class="character-info-content">
            <button class="info-close-btn" id="infoCloseBtn">×</button>
            <div class="info-character-display">
                <div class="info-character-sprite" id="infoCharacterSprite"></div>
                <h3 id="infoCharacterName">Character Name</h3>
            </div>
            
            <div class="info-stats-grid">
                <div class="info-stat-card hp">
                    <div style="font-size: 24px; font-weight: bold;" id="infoHp">100</div>
                    <div style="font-size: 12px;">❤️ Health</div>
                </div>
                <div class="info-stat-card atk">
                    <div style="font-size: 24px; font-weight: bold;" id="infoAtk">50</div>
                    <div style="font-size: 12px;">⚔️ Attack</div>
                </div>
                <div class="info-stat-card spd">
                    <div style="font-size: 24px; font-weight: bold;" id="infoSpd">8</div>
                    <div style="font-size: 12px;">⚡ Speed</div>
                </div>
            </div>
            
            <div class="info-attacks">
                <h4>Available Attacks:</h4>
                <div id="infoAttacksList"></div>
            </div>
            
            <div class="info-effectiveness">
                <h4>Type Effectiveness:</h4>
                <p style="font-size: 12px; color: #666; margin-bottom: 10px;">When this character attacks:</p>
                <div class="effectiveness-grid" id="infoEffectivenessGrid"></div>
            </div>
        </div>
    </div>

    <script>
        const GENES = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Purple'];
        const GENE_COLORS = {
            'Red': '#ef5350',
            'Orange': '#ff8a65', 
            'Yellow': '#ffeb3b',
            'Green': '#66bb6a',
            'Blue': '#42a5f5',
            'Purple': '#ab47bc'
        };

        // Lighter versions for same-gene gradients
        const GENE_LIGHT_COLORS = {
            'Red': '#ffcdd2',
            'Orange': '#ffccbc', 
            'Yellow': '#fff9c4',
            'Green': '#c8e6c9',
            'Blue': '#bbdefb',
            'Purple': '#e1bee7'
        };

        // Darker versions for same-gene gradients
        const GENE_DARK_COLORS = {
            'Red': '#c62828',
            'Orange': '#e65100', 
            'Yellow': '#f57f17',
            'Green': '#2e7d32',
            'Blue': '#1565c0',
            'Purple': '#6a1b9a'
        };

        const GENE_SYMBOLS = {
            'Red': '🥀',
            'Orange': '🔥',
            'Yellow': '🌤️',
            'Green': '🍃',
            'Blue': '🌊',
            'Purple': '🔮',
            'Neutral': '🕊️'
        };

        // Type effectiveness system: Red→Orange→Yellow→Green→Blue→Purple→Red
        const TYPE_EFFECTIVENESS = {
            'Red': { 'Orange': 1.5, 'Yellow': 1.25, 'Purple': 0.5, 'Blue': 0.75 },
            'Orange': { 'Yellow': 1.5, 'Green': 1.25, 'Red': 0.5, 'Purple': 0.75 },
            'Yellow': { 'Green': 1.5, 'Blue': 1.25, 'Orange': 0.5, 'Red': 0.75 },
            'Green': { 'Blue': 1.5, 'Purple': 1.25, 'Yellow': 0.5, 'Orange': 0.75 },
            'Blue': { 'Purple': 1.5, 'Red': 1.25, 'Green': 0.5, 'Yellow': 0.75 },
            'Purple': { 'Red': 1.5, 'Orange': 1.25, 'Blue': 0.5, 'Green': 0.75 }
        };

        // Class Boost system
        const CLASS_BOOSTS = {
            'Blue': { description: '+1⚡ to Your Team', type: 'teammate', stat: 'speed', value: 1 },
            'Red': { description: '+4⚔️ to Your Team', type: 'teammate', stat: 'attack', value: 4 },
            'Yellow': { description: '+16❤️ to Your Team', type: 'teammate', stat: 'hp', value: 16 },
            'Orange': { description: '-1⚡ to Enemy Team', type: 'enemy', stat: 'speed', value: -1 },
            'Green': { description: '-4⚔️ to Enemy Team', type: 'enemy', stat: 'attack', value: -4 },
            'Purple': { description: '-16❤️ to Enemy Team', type: 'enemy', stat: 'hp', value: -16 },
            'Neutral': { description: 'Neutral ⇶ (1/2 ⚔️)', type: 'special' },
            'Splash': { description: '3/4 ⚔️ for ⇶', type: 'special' }
        };

        class GameCharacter {
            constructor(id, genes, unlocked = false) {
                this.id = id;
                this.genes = genes;
                this.unlocked = unlocked;
                this.symbol = this.generateSymbol();
                this.stats = this.generateStats();
                this.baseStats = { ...this.stats }; // Store original stats
            }

            generateSymbol() {
                if (this.genes.length === 1) {
                    return GENE_SYMBOLS[this.genes[0]];
                } else {
                    return `${GENE_SYMBOLS[this.genes[0]]}${GENE_SYMBOLS[this.genes[1]]}`;
                }
            }

            getStatDistribution() {
                // New formula: HP/4 + ATK + SPD×4 = 80
                const statMap = {
                    // Singles
                    'Red': [64, 48, 4],
                    'Orange': [128, 32, 4], 
                    'Yellow': [192, 16, 4],
                    'Green': [128, 16, 8],
                    'Blue': [64, 16, 12],
                    'Purple': [64, 32, 8],
                    
                    // Same-gene doubles
                    'Red-Red': [80, 40, 5],
                    'Orange-Orange': [112, 28, 6],
                    'Yellow-Yellow': [160, 20, 5],
                    'Green-Green': [112, 24, 7],
                    'Blue-Blue': [80, 20, 10],
                    'Purple-Purple': [96, 28, 7],
                    
                    // Different-gene doubles
                    'Red-Orange': [112, 36, 4],
                    'Red-Yellow': [160, 24, 4],
                    'Red-Green': [112, 24, 7],
                    'Red-Blue': [64, 24, 10],
                    'Red-Purple': [64, 36, 7],
                    'Orange-Red': [80, 44, 4],
                    'Orange-Yellow': [176, 20, 4],
                    'Orange-Green': [128, 20, 7],
                    'Orange-Blue': [80, 20, 10],
                    'Orange-Purple': [80, 32, 7],
                    'Yellow-Red': [96, 40, 4],
                    'Yellow-Orange': [144, 28, 4],
                    'Yellow-Green': [144, 16, 7],
                    'Yellow-Blue': [96, 16, 10],
                    'Yellow-Purple': [96, 28, 7],
                    'Green-Red': [80, 40, 5],
                    'Green-Orange': [128, 28, 5],
                    'Green-Yellow': [176, 16, 5],
                    'Green-Blue': [80, 16, 11],
                    'Green-Purple': [80, 28, 8],
                    'Blue-Red': [64, 40, 6],
                    'Blue-Orange': [112, 28, 6],
                    'Blue-Yellow': [160, 16, 6],
                    'Blue-Green': [112, 16, 9],
                    'Blue-Purple': [64, 28, 9],
                    'Purple-Red': [64, 44, 5],
                    'Purple-Orange': [112, 32, 5],
                    'Purple-Yellow': [160, 20, 5],
                    'Purple-Green': [112, 20, 8],
                    'Purple-Blue': [64, 20, 11]
                };
                
                return statMap[this.id] || [64, 16, 4];
            }

            generateStats() {
                const [hp, attack, speed] = this.getStatDistribution();
                
                return {
                    hp: hp,
                    maxHp: hp,
                    attack: attack,
                    speed: speed
                };
            }

            getClassBoostContribution() {
                const contributions = {};
                
                if (this.genes.length === 1) {
                    // Single gene characters contribute 1 count to their gene and 1 to Neutral
                    const gene = this.genes[0];
                    contributions[gene] = 1;
                    contributions['Neutral'] = 1;
                } else if (this.genes[0] === this.genes[1]) {
                    // Same gene doubles contribute 2 counts to their gene and 1 to Splash
                    const gene = this.genes[0];
                    contributions[gene] = 2;
                    contributions['Splash'] = 1;
                } else {
                    // Different gene doubles contribute 1 count to each gene (NO Splash)
                    contributions[this.genes[0]] = 1;
                    contributions[this.genes[1]] = 1;
                }
                
                return contributions;
            }

            getActiveClassBoosts(teamContributions) {
                const activeBoosts = [];
                
                for (const [gene, count] of Object.entries(teamContributions)) {
                    if (count >= 3 && CLASS_BOOSTS[gene]) {
                        activeBoosts.push({
                            gene: gene,
                            ...CLASS_BOOSTS[gene]
                        });
                    }
                }
                
                // Limit to 2 active boosts maximum
                return activeBoosts;
            }

            hashCode(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash;
            }

            getAttackGenes() {
                if (this.genes.length === 1) {
                    return [
                        { gene: this.genes[0], type: 'single' },
                        { gene: 'Neutral', type: 'single' }
                    ];
                } else if (this.genes[0] === this.genes[1]) {
                    // Same gene: first attack is single, second is splash
                    return [
                        { gene: this.genes[0], type: 'single' },
                        { gene: this.genes[0], type: 'splash' }
                    ];
                } else {
                    // Different genes: both are single target
                    return [
                        { gene: this.genes[0], type: 'single' },
                        { gene: this.genes[1], type: 'single' }
                    ];
                }
            }

            getEffectiveness(attackGene, defendingCharacter) {
                if (attackGene === 'Neutral') return 1.0;
                
                // Only use the FIRST gene for defense
                const defendingGene = defendingCharacter.genes[0];
                
                return TYPE_EFFECTIVENESS[attackGene]?.[defendingGene] || 1.0;
            }

            calculateDamage(attackGene, defendingCharacter, activeBoosts = []) {
                const baseDamage = this.stats.attack;
                const effectiveness = this.getEffectiveness(attackGene, defendingCharacter);
                
                // Check for Dove of Peace boost (Neutral becomes splash at 75%)
                const hasNeutralBoost = activeBoosts.some(boost => boost.gene === 'Neutral');
                if (attackGene === 'Neutral' && hasNeutralBoost) {
                    // This will be handled in processSplashAttack with 75% damage
                    return Math.floor(baseDamage * effectiveness * 0.75);
                }
                
                return Math.floor(baseDamage * effectiveness);
            }
        }

        class BattleSystem {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.playerTeam = [];
                this.enemyTeam = [];
                this.turnQueue = [];
                this.currentTurnIndex = 0;
                this.battlePhase = 'setup'; // setup, battle, ended
                this.battleLog = [];
                this.difficulty = 'easy'; // Default difficulty
                this.actionBars = {}; // Track action bar fill for each character
                this.turnHistory = []; // Track completed turns
                this.upcomingTurns = []; // Pre-calculated upcoming turns
                this.ACTION_THRESHOLD = 1000; // Action bar threshold
                this.isProcessingTurn = false; // Flag to prevent multiple attacks in one turn
                this.attackButtonsDisabled = false; // Flag to disable attack buttons
                this.animationSpeed = gameInstance.battleSystem?.animationSpeed || 1;
                this.selectedAttackGenes = {}; // Changed from single to object
                this.persistentAttackMode = false;
                this.battleControlsInitialized = false;
            }

            showTargetSelectionDirectly(attackGene) {
                const attackButtonsElement = document.getElementById('attackButtons');
                const availableTargets = this.enemyTeam.filter(char => char.hp > 0);
                
                const targetContainer = document.createElement('div');
                targetContainer.style.display = 'flex';
                targetContainer.style.gap = '8px';
                targetContainer.style.justifyContent = 'center';
                targetContainer.style.flexWrap = 'wrap';
                targetContainer.style.width = '100%';
                
                availableTargets.forEach(target => {
                    const button = document.createElement('button');
                    button.className = 'attack-btn';
                    
                    if (target.genes.length === 1) {
                        button.style.background = `linear-gradient(45deg, ${GENE_COLORS[target.genes[0]]}, ${GENE_LIGHT_COLORS[target.genes[0]]})`;
                    } else if (target.genes[0] === target.genes[1]) {
                        const geneColor = GENE_COLORS[target.genes[0]];
                        const darkColor = GENE_DARK_COLORS[target.genes[0]];
                        button.style.background = `linear-gradient(45deg, ${geneColor}, ${darkColor}, ${geneColor})`;
                    } else {
                        button.style.background = `linear-gradient(45deg, ${GENE_COLORS[target.genes[0]]}, ${GENE_COLORS[target.genes[1]]})`;
                    }
                    
                    button.textContent = target.id;
                    button.style.color = 'white';
                    button.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.7)';
                    button.style.minWidth = '120px';
                    button.style.maxWidth = '140px';
                    button.style.flex = '1 1 120px';
                    
                    button.addEventListener('click', async () => {
                        if (this.isProcessingTurn) return;
                        
                        const allTargetButtons = targetContainer.querySelectorAll('button');
                        allTargetButtons.forEach(btn => btn.disabled = true);
                        
                        await this.showAttackAnimation(this.getCurrentCharacter(), target);
                        this.processTurn(attackGene, target);
                    });
                    
                    targetContainer.appendChild(button);
                });
                
                attackButtonsElement.appendChild(targetContainer);
            }

            setAnimationSpeed(speed) {
                this.animationSpeed = speed;
            }

            showAttackAnimation(attacker, target) {
                return new Promise(resolve => {
                    const attackerElement = document.querySelector(`[data-battle-char="${attacker.id}"]`);
                    const targetElement = document.querySelector(`[data-battle-char="${target.id}"]`);

                    if (attackerElement) {
                        attackerElement.style.boxShadow = '0 0 20px #ffeb3b';
                        attackerElement.style.transform = 'scale(1.1)';
                    }
                    
                    setTimeout(() => {
                        if (targetElement) {
                            targetElement.style.boxShadow = '0 0 20px #ff6b6b';
                        }
                        
                        setTimeout(() => {
                            if (attackerElement) {
                                attackerElement.style.boxShadow = '';
                                attackerElement.style.transform = '';
                            }
                            if (targetElement) {
                                targetElement.style.boxShadow = '';
                            }
                            resolve();
                        }, Math.floor(800 / this.animationSpeed));
                    }, Math.floor(500 / this.animationSpeed));
                });
            }

            setDifficulty(difficulty) {
                this.difficulty = difficulty;
            }

            calculateTeamClassBoosts(team) {
                const teamContributions = {};
                
                // Count contributions from all team members
                team.forEach(character => {
                    const contributions = character.getClassBoostContribution();
                    for (const [gene, count] of Object.entries(contributions)) {
                        teamContributions[gene] = (teamContributions[gene] || 0) + count;
                    }
                });
                
                // Get active boosts for the team
                const sampleCharacter = team[0];
                return sampleCharacter ? sampleCharacter.getActiveClassBoosts(teamContributions) : [];
            }

            applyClassBoosts() {
                const playerBoosts = this.calculateTeamClassBoosts(this.playerTeam);
                const enemyBoosts = this.calculateTeamClassBoosts(this.enemyTeam);
                
                // Reset all characters to base stats first
                [...this.playerTeam, ...this.enemyTeam].forEach(char => {
                    char.stats = { ...char.baseStats };
                    char.hp = Math.min(char.hp, char.stats.maxHp); // Don't exceed new max HP
                });
                
                // Apply player team boosts
                this.applyBoostsToTeams(playerBoosts, this.playerTeam, this.enemyTeam);
                
                // Apply enemy team boosts  
                this.applyBoostsToTeams(enemyBoosts, this.enemyTeam, this.playerTeam);
                
                // Store active boosts for display
                this.playerActiveBoosts = playerBoosts;
                this.enemyActiveBoosts = enemyBoosts;
            }

            applyBoostsToTeams(boosts, friendlyTeam, enemyTeam) {
                boosts.forEach(boost => {
                    if (boost.type === 'teammate') {
                        // Apply boost to friendly team
                        friendlyTeam.forEach(char => {
                            if (boost.stat === 'hp') {
                                char.stats.maxHp += boost.value;
                                char.hp += boost.value; // Also increase current HP
                            } else {
                                char.stats[boost.stat] += boost.value;
                            }
                        });
                    } else if (boost.type === 'enemy') {
                        // Apply debuff to enemy team
                        enemyTeam.forEach(char => {
                            if (boost.stat === 'hp') {
                                char.stats.maxHp = Math.max(1, char.stats.maxHp + boost.value);
                                char.hp = Math.min(char.hp, char.stats.maxHp); // Don't exceed new max
                            } else {
                                char.stats[boost.stat] = Math.max(1, char.stats[boost.stat] + boost.value);
                            }
                        });
                    }
                });
            }

            clearAllTimers() {
                // Clear any pending AI turn timers
                if (this.aiTurnTimer) {
                    clearTimeout(this.aiTurnTimer);
                    this.aiTurnTimer = null;
                }
                
                // Clear any other pending timers that might be running
                if (this.nextTurnTimer) {
                    clearTimeout(this.nextTurnTimer);
                    this.nextTurnTimer = null;
                }
            }

            showQuitConfirmation() {
                const popup = document.createElement('div');
                popup.className = 'confirmation-popup show';
                popup.innerHTML = `
                    <div class="confirmation-content">
                        <h3 style="color: #666; margin-bottom: 15px;">Quit Battle?</h3>
                        <p style="color: #888; margin-bottom: 20px;">Are you sure you want to quit this battle? Your progress will be lost.</p>
                        <div class="confirmation-buttons">
                            <button class="confirm-btn" id="confirmQuit">Yes, Quit</button>
                            <button class="cancel-btn" id="cancelQuit">Cancel</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(popup);
                
                document.getElementById('confirmQuit').addEventListener('click', () => {
                    popup.remove();
                    this.returnToSetup();
                });
                
                document.getElementById('cancelQuit').addEventListener('click', () => {
                    popup.remove();
                });
            }

            setupBattle(playerTeam) {
                this.playerTeam = playerTeam.map(char => Object.assign(Object.create(Object.getPrototypeOf(char)), char));
                this.playerTeam.forEach(char => {
                    char.hp = char.stats.maxHp;
                    char.isPlayer = true;
                });

                this.generateEnemyTeam();
                
                // Apply class boosts before battle starts
                this.applyClassBoosts();
                
                this.createTurnQueue();
                
                this.battlePhase = 'battle';
                this.battleLog = [];
                this.previousFirstTurn = null;
                
                const currentSpeed = this.animationSpeed || 1;
                this.setAnimationSpeed(currentSpeed);

                this.attackButtonsDisabled = false;
                this.isProcessingTurn = false;
                
                this.renderBattleArena();
                
                const firstChar = this.getCurrentCharacter();
                if (firstChar && !firstChar.isPlayer) {
                    setTimeout(() => this.processAITurn(), 1500);
                }
            }

            generateEnemyTeam() {
                const availableCharacters = Object.values(this.game.characters)
                    .filter(char => char.unlocked && !this.playerTeam.some(pChar => pChar.id === char.id));
                
                // If not enough unique characters, allow duplicates but mark them differently
                if (availableCharacters.length < 3) {
                    const allAvailable = Object.values(this.game.characters).filter(char => char.unlocked);
                    this.enemyTeam = [];
                    for (let i = 0; i < 3; i++) {
                        const randomChar = allAvailable[Math.floor(Math.random() * allAvailable.length)];
                        const enemyChar = Object.assign(Object.create(Object.getPrototypeOf(randomChar)), randomChar);
            
                        // Add unique suffix if character already exists in player team
                        if (this.playerTeam.some(pChar => pChar.id === enemyChar.id)) {
                            enemyChar.id = `${enemyChar.id}-E${i + 1}`;
                        }
                        
                        enemyChar.hp = enemyChar.stats.maxHp;
                        enemyChar.isPlayer = false;
                        this.enemyTeam.push(enemyChar);
                    }
                } else {
                    this.enemyTeam = [];
                    for (let i = 0; i < 3; i++) {
                        const randomChar = availableCharacters[Math.floor(Math.random() * availableCharacters.length)];
                        const enemyChar = Object.assign(Object.create(Object.getPrototypeOf(randomChar)), randomChar);
                        enemyChar.hp = enemyChar.stats.maxHp;
                        enemyChar.isPlayer = false;
                        this.enemyTeam.push(enemyChar);
                        
                        // Remove from available to prevent duplicates
                        const index = availableCharacters.findIndex(char => char.id === randomChar.id);
                        availableCharacters.splice(index, 1);
                    }
                }
            }

            createTurnQueue() {
                // Initialize action bars for all alive characters
                const allCharacters = [...this.playerTeam, ...this.enemyTeam]
                    .filter(char => char.hp > 0);
                
                // Reset action bars
                this.actionBars = {};
                allCharacters.forEach(char => {
                    this.actionBars[this.getCharId(char)] = 0;
                });
                
                // Pre-calculate the next 20 turns for display
                this.calculateUpcomingTurns(20);
                
                // Set the initial turn queue for display
                this.turnQueue = this.upcomingTurns.slice(0, 6);
            }

            getCharId(character) {
                // Create unique ID for each character including team info
                return `${character.id}-${character.isPlayer ? 'P' : 'E'}`;
            }

            calculateUpcomingTurns(numberOfTurns) {
                const allCharacters = [...this.playerTeam, ...this.enemyTeam]
                    .filter(char => char.hp > 0);
                
                if (allCharacters.length === 0) {
                    this.upcomingTurns = [];
                    return;
                }
                
                // Clone current action bars for simulation
                const simActionBars = { ...this.actionBars };
                const turns = [];
                
                while (turns.length < numberOfTurns) {
                    // Increment all action bars by their speed
                    allCharacters.forEach(char => {
                        const charId = this.getCharId(char);
                        if (simActionBars[charId] !== undefined) {
                            simActionBars[charId] += char.stats.speed;
                        }
                    });
                    
                    // Find characters that reached the threshold
                    const readyChars = allCharacters.filter(char => {
                        const charId = this.getCharId(char);
                        return simActionBars[charId] >= this.ACTION_THRESHOLD;
                    });
                    
                    if (readyChars.length > 0) {
                        // Sort by tie-breaking rules
                        readyChars.sort((a, b) => {
                            const aBar = simActionBars[this.getCharId(a)];
                            const bBar = simActionBars[this.getCharId(b)];
                            
                            // First tiebreaker: Higher action bar value
                            if (aBar !== bBar) return bBar - aBar;
                            
                            // Second tiebreaker: Lower base speed
                            if (a.stats.speed !== b.stats.speed) {
                                return a.stats.speed - b.stats.speed;
                            }
                            
                            // Third tiebreaker: Player advantage
                            if (a.isPlayer !== b.isPlayer) {
                                return a.isPlayer ? -1 : 1;
                            }
                            
                            // Fourth tiebreaker: Selection order (using array index)
                            const aIndex = a.isPlayer ? 
                                this.playerTeam.indexOf(a) : 
                                this.enemyTeam.indexOf(a);
                            const bIndex = b.isPlayer ? 
                                this.playerTeam.indexOf(b) : 
                                this.enemyTeam.indexOf(b);
                            return aIndex - bIndex;
                        });
                        
                        // Process each ready character
                        readyChars.forEach(char => {
                            const charId = this.getCharId(char);
                            simActionBars[charId] -= this.ACTION_THRESHOLD;
                            turns.push(char);
                        });
                    }
                }
                
                this.upcomingTurns = turns;
            }

            getCurrentCharacter() {
                if (this.upcomingTurns.length === 0) return null;
                return this.upcomingTurns[0];
            }

            nextTurn() {
                const currentChar = this.getCurrentCharacter();
                if (currentChar) {
                    const charId = this.getCharId(currentChar);
                    
                    // Actually consume the action bar for the character that just acted
                    this.actionBars[charId] -= this.ACTION_THRESHOLD;
                    
                    // Move to next turn
                    this.turnHistory.push(this.upcomingTurns.shift());
                    
                    // Calculate more turns if needed
                    if (this.upcomingTurns.length < 20) {
                        this.calculateUpcomingTurns(20);
                    }
                    
                    // Update the display queue (sliding window of 6)
                    this.turnQueue = this.upcomingTurns.slice(0, 6);
                }
                
                // Update display
                this.updateBattleDisplay();
                
                const nextChar = this.getCurrentCharacter();
                // In nextTurn method, replace the setTimeout:
                if (nextChar && !nextChar.isPlayer) {
                    this.nextTurnTimer = setTimeout(() => {
                        this.nextTurnTimer = null;
                        this.processAITurn();
                    }, Math.floor(2500 / this.animationSpeed));
                } else if (nextChar && nextChar.isPlayer) {
                    // Re-enable attack buttons when it's the player's turn
                    this.attackButtonsDisabled = false;
                    this.isProcessingTurn = false;
                }
            }

            progressActionBars() {
                // Progress all action bars based on speed
                const allCharacters = [...this.playerTeam, ...this.enemyTeam]
                    .filter(char => char.hp > 0);
                
                allCharacters.forEach(char => {
                    const charId = this.getCharId(char);
                    if (this.actionBars[charId] !== undefined) {
                        this.actionBars[charId] += char.stats.speed;
                    }
                });
                
                // Find who reached the threshold
                const readyCharacters = allCharacters.filter(char => {
                    const charId = this.getCharId(char);
                    return this.actionBars[charId] >= this.ACTION_THRESHOLD;
                });
                
                // Sort by tiebreaking rules and return
                if (readyCharacters.length > 0) {
                    readyCharacters.sort((a, b) => {
                        // Tiebreaker 1: Higher action bar value
                        const aBar = this.actionBars[this.getCharId(a)];
                        const bBar = this.actionBars[this.getCharId(b)];
                        if (aBar !== bBar) return bBar - aBar;
                        
                        // Tiebreaker 2: Higher base speed
                        if (a.stats.speed !== b.stats.speed) {
                            return a.stats.speed - b.stats.speed;
                        }
                        
                        // Tiebreaker 3: Player advantage
                        if (a.isPlayer !== b.isPlayer) {
                            return a.isPlayer ? -1 : 1;
                        }
                        
                        // Tiebreaker 4: Selection order
                        const aIndex = a.isPlayer ? 
                            this.playerTeam.indexOf(a) : 
                            this.enemyTeam.indexOf(a);
                        const bIndex = b.isPlayer ? 
                            this.playerTeam.indexOf(b) : 
                            this.enemyTeam.indexOf(b);
                        return aIndex - bIndex;
                    });
                    
                    return readyCharacters[0];
                }
                
                return null;
            }

            updateTurnQueue() {
                // Remove defeated characters from action bars
                const allCharacters = [...this.playerTeam, ...this.enemyTeam];
                allCharacters.forEach(char => {
                    if (char.hp <= 0) {
                        const charId = this.getCharId(char);
                        delete this.actionBars[charId];
                    }
                });
                
                // Recalculate upcoming turns
                this.calculateUpcomingTurns(20);
                this.turnQueue = this.upcomingTurns.slice(0, 6);
            }

            async processTurn(attackObj, targetCharacter) {
                // Prevent multiple attacks in one turn
                if (this.isProcessingTurn) {
                    return;
                }
                
                this.isProcessingTurn = true;
                
                const attacker = this.getCurrentCharacter();
                if (!attacker || attacker.hp <= 0) {
                    this.isProcessingTurn = false;
                    this.attackButtonsDisabled = false; // Re-enable buttons
                    this.nextTurn();
                    return;
                }

                if (attackObj.type === 'splash') {
                    await this.processSplashAttack(attacker, attackObj.gene);
                } else {
                    await this.processSingleAttack(attacker, attackObj.gene, targetCharacter);
                }
                
                // Check for battle end
                if (this.checkBattleEnd()) {
                    this.isProcessingTurn = false;
                    this.attackButtonsDisabled = false; // Re-enable buttons
                    return;
                }
                
                // Reset flags before calling nextTurn
                this.isProcessingTurn = false;
                this.attackButtonsDisabled = false;
                this.nextTurn();
            }

            async processSingleAttack(attacker, attackGene, targetCharacter) {
                const activeBoosts = attacker.isPlayer ? this.playerActiveBoosts : this.enemyActiveBoosts;
                
                // Check for Neutral boost (Neutral becomes splash at 50%)
                const hasNeutralBoost = activeBoosts && activeBoosts.some(boost => boost.gene === 'Neutral');
                if (attackGene === 'Neutral' && hasNeutralBoost) {
                    // Convert to splash attack at 50% damage
                    await this.processSplashAttack(attacker, attackGene, 0.5);
                    return;
                }
                
                const baseDamage = attacker.stats.attack;
                const effectiveness = attacker.getEffectiveness(attackGene, targetCharacter);
                const finalDamage = Math.floor(baseDamage * effectiveness);
                
                targetCharacter.hp = Math.max(0, targetCharacter.hp - finalDamage);
                
                const attackSymbol = attackGene === 'Neutral' ? '⚪' : GENE_SYMBOLS[attackGene];
                const defenseSymbols = targetCharacter.genes.map(gene => GENE_SYMBOLS[gene]).join('');
                
                let effectivenessText = '';
                let logClass = 'damage';
                
                if (effectiveness > 1) {
                    const bonusPercent = Math.round((effectiveness - 1) * 100);
                    if (effectiveness >= 1.5) {
                        effectivenessText = `🚑Very effective (+${bonusPercent}%)`;
                    } else {
                        effectivenessText = `📈Effective (+${bonusPercent}%)`;
                    }
                    logClass = 'super-effective';
                } else if (effectiveness < 1) {
                    const penaltyPercent = Math.round((1 - effectiveness) * 100);
                    if (effectiveness <= 0.5) {
                        effectivenessText = `🗿Not effective at all (-${penaltyPercent}%)`;
                    } else {
                        effectivenessText = `📉Not too effective (-${penaltyPercent}%)`;
                    }
                    logClass = 'not-very-effective';
                } else {
                    effectivenessText = `Normal damage`;
                }
                
                const detailedLog = `${attacker.id} (${attackSymbol}${attackGene}) → ${targetCharacter.id} (${defenseSymbols}${targetCharacter.genes.join('-')}) | Base: ${baseDamage} × ${effectiveness} = ${finalDamage} dmg | ${effectivenessText}`;
                
                const teamClass = attacker.isPlayer ? 'player-attack' : 'enemy-attack';
                this.addBattleLog(detailedLog, `${logClass} ${teamClass}`);
                
                this.showDamageAnimation(targetCharacter, finalDamage, effectiveness);
                
                if (targetCharacter.hp <= 0) {
                    this.addBattleLog(`💀 ${targetCharacter.id} was defeated!`, `damage ${teamClass}`);
                    this.updateTurnQueue();
                }
            }

            async processSplashAttack(attacker, attackGene, damageMultiplier = null) {
                const targets = attacker.isPlayer ? 
                    this.enemyTeam.filter(char => char.hp > 0).slice(0, 3) :
                    this.playerTeam.filter(char => char.hp > 0).slice(0, 3);
                    
                const teamClass = attacker.isPlayer ? 'player-attack' : 'enemy-attack';
                
                // Determine damage multiplier
                let splashMultiplier = 0.5; // Default 50%
                if (damageMultiplier !== null) {
                    splashMultiplier = damageMultiplier; // For Neutral (50%)
                } else {
                    // Check for Splash boost (75% instead of 50%)
                    const activeBoosts = attacker.isPlayer ? this.playerActiveBoosts : this.enemyActiveBoosts;
                    const hasSplashBoost = activeBoosts && activeBoosts.some(boost => boost.gene === 'Splash');
                    if (hasSplashBoost) {
                        splashMultiplier = 0.75;
                    }
                }
    
                const splashType = damageMultiplier !== null ? 'Neutral' : '';
                this.addBattleLog(`💥💥 ${attacker.id} uses ${GENE_SYMBOLS[attackGene]} ${attackGene} ⇶ Attack!`, `super-effective ${teamClass}`);
                
                for (const target of targets) {
                    const baseDamage = attacker.stats.attack;
                    const effectiveness = attacker.getEffectiveness(attackGene, target);
                    const singleDamage = Math.floor(baseDamage * effectiveness);
                    const splashDamage = Math.floor(singleDamage * splashMultiplier);
                    
                    target.hp = Math.max(0, target.hp - splashDamage);
                    
                    const defenseSymbols = target.genes.map(gene => GENE_SYMBOLS[gene]).join('');
                    const detailedLog = `${attacker.id} (${GENE_SYMBOLS[attackGene]}${attackGene}) ⇶ → ${target.id} (${defenseSymbols}${target.genes.join('-')}) | Base: ${baseDamage} × ${effectiveness} × ${splashMultiplier} = ${splashDamage} dmg`;
                    
                    this.addBattleLog(detailedLog, `damage ${teamClass}`);
                    this.showDamageAnimation(target, splashDamage, effectiveness);
                    
                    if (target.hp <= 0) {
                        this.addBattleLog(`💀 ${target.id} was defeated!`, `damage ${teamClass}`);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                this.updateTurnQueue();
            }

            processAITurn() {
                const attacker = this.getCurrentCharacter();
                const availableTargets = this.playerTeam.filter(char => char.hp > 0);
                
                if (availableTargets.length === 0) return;
                
                let selectedAttack, selectedTarget;
                
                // Add "AI is thinking..." message
                this.addBattleLog(`🤖 ${attacker.id} is thinking...`, 'enemy-attack');
                
                // Delay the AI decision by 2 seconds
                this.aiTurnTimer = setTimeout(() => {
                // Clear the timer reference since it's about to execute
                this.aiTurnTimer = null;
                
                switch(this.difficulty) {
                        case 'easy':
                            // Random everything
                            const attackObjs = attacker.getAttackGenes();
                            selectedAttack = attackObjs[Math.floor(Math.random() * attackObjs.length)];
                            selectedTarget = availableTargets[Math.floor(Math.random() * availableTargets.length)];
                            break;
                            
                        case 'normal':
                            // 50% chance to make smart move, 50% random
                            if (Math.random() < 0.5) {
                                const bestMove = this.calculateBestMove(attacker, availableTargets);
                                selectedAttack = bestMove.attack;
                                selectedTarget = bestMove.target;
                            } else {
                                const attackObjs = attacker.getAttackGenes();
                                selectedAttack = attackObjs[Math.floor(Math.random() * attackObjs.length)];
                                selectedTarget = availableTargets[Math.floor(Math.random() * availableTargets.length)];
                            }
                            break;
                            
                        case 'hard':
                            // 80% chance to make smart move
                            if (Math.random() < 0.8) {
                                const bestMove = this.calculateBestMove(attacker, availableTargets);
                                selectedAttack = bestMove.attack;
                                selectedTarget = bestMove.target;
                            } else {
                                const attackObjs = attacker.getAttackGenes();
                                selectedAttack = attackObjs[Math.floor(Math.random() * attackObjs.length)];
                                selectedTarget = availableTargets[Math.floor(Math.random() * availableTargets.length)];
                            }
                            break;
                            
                        case 'extreme':
                            // Always make the optimal move
                            const bestMove = this.calculateBestMove(attacker, availableTargets);
                            selectedAttack = bestMove.attack;
                            selectedTarget = bestMove.target;
                            break;
                    }
                    
                    this.processTurn(selectedAttack, selectedTarget);
                }, Math.floor(2000 / this.animationSpeed));
            }

            calculateBestMove(attacker, availableTargets) {
                const attackObjs = attacker.getAttackGenes();
                let bestMove = null;
                let bestScore = -Infinity;
                
                for (const attackObj of attackObjs) {
                    if (attackObj.type === 'splash') {
                        // Only use splash if there are multiple targets AND it's actually beneficial
                        if (availableTargets.length <= 1) {
                            continue; // Skip splash attacks when only one target
                        }
                        
                        let totalDamage = 0;
                        let killCount = 0;
                        let totalTargetValue = 0;
                        
                        for (const target of availableTargets) {
                            const effectiveness = attacker.getEffectiveness(attackObj.gene, target);
                            const damage = Math.floor((attacker.stats.attack * effectiveness) / 2);
                            totalDamage += damage;
                            totalTargetValue += target.stats.attack; // Factor in target threat level
                            
                            if (damage >= target.hp) {
                                killCount++;
                            }
                        }
                        
                        // Only use splash if it can kill at least 2 targets OR deals significant total damage
                        if (killCount >= 2 || (totalDamage > attacker.stats.attack * 1.5 && availableTargets.length >= 3)) {
                            const score = totalDamage + (killCount * 500) + (totalTargetValue * 0.1);
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestMove = { attack: attackObj, target: availableTargets[0] };
                            }
                        }
                    } else {
                        // Single attacks - prioritize finishing kills and effectiveness
                        for (const target of availableTargets) {
                            const effectiveness = attackObj.gene === 'Neutral' ? 1 : attacker.getEffectiveness(attackObj.gene, target);
                            const damage = Math.floor(attacker.stats.attack * effectiveness);
                            
                            let score = 0;
                            
                            // MASSIVE bonus for killing an enemy (top priority)
                            if (damage >= target.hp) {
                                score += 2000; // Increased from 1000
                                
                                // Extra bonus for killing high-threat targets
                                score += target.stats.attack * 2;
                                
                                // Bonus for effectiveness on kills
                                if (effectiveness >= 1.25) {
                                    score += 300;
                                }
                            } else {
                                // Base damage score (only if not killing)
                                score += damage;
                                
                                // Bonus for bringing target into kill range for next turn
                                const remainingHp = target.hp - damage;
                                if (remainingHp <= attacker.stats.attack * 1.5) {
                                    score += 400; // Bonus for setting up kills
                                }
                                
                                // Effectiveness bonuses (reduced when not killing)
                                if (effectiveness >= 1.5) {
                                    score += 200;
                                } else if (effectiveness >= 1.25) {
                                    score += 100;
                                } else if (effectiveness <= 0.75) {
                                    score -= 200; // Heavy penalty for ineffective attacks
                                }
                                
                                // Consider target threat level
                                score += target.stats.attack * 0.3;
                                
                                // Bonus for hitting already wounded enemies
                                const hpPercentage = target.hp / target.stats.maxHp;
                                if (hpPercentage < 0.4) {
                                    score += 300; // Focus fire on wounded targets
                                } else if (hpPercentage < 0.6) {
                                    score += 150;
                                }
                            }
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestMove = { attack: attackObj, target: target };
                            }
                        }
                    }
                }
                
                // Fallback to any available move if no good move found
                return bestMove || { 
                    attack: attackObjs[0], 
                    target: availableTargets[0] 
                };
            }

            checkBattleEnd() {
                const playerAlive = this.playerTeam.some(char => char.hp > 0);
                const enemyAlive = this.enemyTeam.some(char => char.hp > 0);
                
                if (!playerAlive || !enemyAlive) {
                    this.endBattle(playerAlive);
                    return true;
                }
                return false;
            }

            endBattle(playerWon) {
                this.clearAllTimers(); // Add this line
                this.battlePhase = 'ended';
                this.isProcessingTurn = false; // Reset the flag
                this.attackButtonsDisabled = false; // Reset attack buttons
                const message = playerWon ? 'Victory! You won the battle!' : 'Defeat! Better luck next time!';
                const teamClass = playerWon ? 'player-attack' : 'enemy-attack';
                this.addBattleLog(message, `super-effective ${teamClass}`);
                
                setTimeout(() => {
                    alert(message);
                    this.returnToSetup();
                }, 2000);
            }

            returnToSetup() {
                this.battleControlsInitialized = false;
                this.clearAllTimers();

                document.body.classList.remove('battle-active');
                
                const teamSetup = document.getElementById('team-setup');
                const battleArena = document.getElementById('battle-arena');
                
                if (teamSetup) teamSetup.style.display = 'block';
                if (battleArena) battleArena.style.display = 'none';
                
                // Hide animation speed control
                const speedControl = document.getElementById('animationSpeedControl');
                if (speedControl) speedControl.classList.remove('show');
                
                // Reset battle log
                this.battleLog = [];
                const logElement = document.getElementById('battleLog');
                if (logElement) {
                    logElement.innerHTML = '';
                }
                
                const modalLogElement = document.getElementById('battleLogModalContent');
                if (modalLogElement) {
                    modalLogElement.innerHTML = '';
                }
                
                // Hide battle log modal if open
                const battleLogModal = document.getElementById('battleLogModal');
                if (battleLogModal) {
                    battleLogModal.classList.remove('show');
                }
                
                this.game.battleSystem = new BattleSystem(this.game);
                this.game.selectedBattleTeam = [];
                this.game.updateBattleTeamSelection();
            }

            showDamageAnimation(targetCharacter, damage, effectiveness) {
                // Use both character ID and team to create unique selector
                const teamPrefix = targetCharacter.isPlayer ? 'player' : 'enemy';
                const targetElement = document.querySelector(`[data-battle-char="${targetCharacter.id}"][data-team="${teamPrefix}"]`);
                if (!targetElement) return;
                
                // Create damage number element
                const damageNum = document.createElement('div');
                damageNum.className = 'damage-number damage-animation';
                
                // Add effectiveness indicator with emote and percentage
                let effectivenessIndicator = '';
                if (effectiveness === 1.5) {
                    effectivenessIndicator = ' 🚑(+50%)';
                    damageNum.classList.add('super-effective');
                } else if (effectiveness === 1.25) {
                    effectivenessIndicator = ' 📈(+25%)';
                    damageNum.classList.add('super-effective');
                } else if (effectiveness === 0.75) {
                    effectivenessIndicator = ' 📉(-25%)';
                    damageNum.classList.add('not-very-effective');
                } else if (effectiveness === 0.5) {
                    effectivenessIndicator = ' 🗿(-50%)';
                    damageNum.classList.add('not-very-effective');
                }
                
                damageNum.textContent = damage + effectivenessIndicator;
                
                const rect = targetElement.getBoundingClientRect();
                damageNum.style.position = 'fixed';
                damageNum.style.left = (rect.left + rect.width / 2) + 'px';
                damageNum.style.top = rect.top + 'px';
                damageNum.style.zIndex = '1000';
                
                document.body.appendChild(damageNum);
                
                setTimeout(() => {
                    if (damageNum.parentNode) {
                        damageNum.remove();
                    }
                }, 2500);
                
                targetElement.classList.add('battle-shake');
                const shakeIntensity = Math.min(damage / 50, 1);
                targetElement.style.setProperty('--shake-intensity', shakeIntensity);
                
                setTimeout(() => {
                    targetElement.classList.remove('battle-shake');
                    targetElement.style.removeProperty('--shake-intensity');
                }, 600);
                
                setTimeout(() => this.updateBattleDisplay(), 200);
            }

            addBattleLog(message, className = '') {
                this.battleLog.push({ message, className });
                if (this.battleLog.length > 15) { // Increased from 10 to 15
                    this.battleLog.shift();
                }
                
                // Update desktop log
                const logElement = document.getElementById('battleLog');
                if (logElement) {
                    logElement.innerHTML = this.battleLog
                        .map(log => `<div class="log-entry ${log.className}">${log.message}</div>`)
                        .join('');
                    logElement.scrollTop = logElement.scrollHeight;
                }
                
                // Update mobile modal log
                const modalLogElement = document.getElementById('battleLogModalContent');
                if (modalLogElement) {
                    modalLogElement.innerHTML = this.battleLog
                        .map(log => `<div class="log-entry ${log.className}">${log.message}</div>`)
                        .join('');
                    modalLogElement.scrollTop = modalLogElement.scrollHeight;
                }
            }

            renderBattleArena() {
                const teamSetup = document.getElementById('team-setup');
                const battleArena = document.getElementById('battle-arena');
                
                if (teamSetup) teamSetup.style.display = 'none';
                if (battleArena) battleArena.style.display = 'block';
                
                // Add class to body for CSS targeting
                document.body.classList.add('battle-active');
                
                this.updateBattleDisplay();
                
                // Show animation speed control during battle
                const speedControl = document.getElementById('animationSpeedControl');
                if (speedControl) speedControl.classList.add('show');
                
                // Add quit button listener
                const quitBtn = document.getElementById('quitBattleBtn');
                if (quitBtn) {
                    quitBtn.replaceWith(quitBtn.cloneNode(true));
                    const newQuitBtn = document.getElementById('quitBattleBtn');
                    newQuitBtn.addEventListener('click', () => this.showQuitConfirmation());
                }
            }

            updateBattleDisplay() {
                this.updateTeamDisplays();
                this.updateTurnOrder();
                this.updateBattleControls();
            }

            updateTeamDisplays() {
                // Update player team
                const playerDisplay = document.getElementById('playerTeamDisplay');
                playerDisplay.innerHTML = '';
                this.playerTeam.forEach(char => {
                    const charElement = this.createBattleCharacterElement(char);
                    playerDisplay.appendChild(charElement);
                });
                
                // Update enemy team
                const enemyDisplay = document.getElementById('enemyTeamDisplay');
                enemyDisplay.innerHTML = '';
                this.enemyTeam.forEach(char => {
                    const charElement = this.createBattleCharacterElement(char);
                    enemyDisplay.appendChild(charElement);
                });
                
                // Update class boost displays
                this.updateClassBoostDisplays();
            }

            updateClassBoostDisplays() {
                // Update player team class boosts
                const playerTeamSection = document.querySelector('.team-section.player-team');
                
                let existingPlayerBoosts = playerTeamSection.querySelector('.class-boosts-display');
                if (existingPlayerBoosts) existingPlayerBoosts.remove();
                
                if (this.playerActiveBoosts && this.playerActiveBoosts.length > 0) {
                    const boostDisplay = document.createElement('div');
                    boostDisplay.className = 'class-boosts-display';
                    boostDisplay.style.cssText = 'position: absolute; top: 10px; left: 10px; font-size: 11px; color: #4ecdc4; font-weight: bold; line-height: 1.3; background: rgba(255,255,255,0.9); padding: 6px 8px; border-radius: 6px; z-index: 10;';
                    
                    const boostTexts = this.playerActiveBoosts.map(boost => {
                        const emoji = this.getBoostEmoji(boost.gene);
                        return `${emoji}${boost.description}`;
                    });
                    
                    boostDisplay.innerHTML = `Class Boosts:<br>${boostTexts.join('<br>')}`;
                    playerTeamSection.style.position = 'relative';
                    playerTeamSection.appendChild(boostDisplay);
                }
                
                // Update enemy team class boosts
                const enemyTeamSection = document.querySelector('.team-section.enemy-team');
                
                let existingEnemyBoosts = enemyTeamSection.querySelector('.class-boosts-display');
                if (existingEnemyBoosts) existingEnemyBoosts.remove();
                
                if (this.enemyActiveBoosts && this.enemyActiveBoosts.length > 0) {
                    const boostDisplay = document.createElement('div');
                    boostDisplay.className = 'class-boosts-display';
                    boostDisplay.style.cssText = 'position: absolute; top: 10px; left: 10px; font-size: 11px; color: #ff6b6b; font-weight: bold; line-height: 1.3; background: rgba(255,255,255,0.9); padding: 6px 8px; border-radius: 6px; z-index: 10;';
                    
                    const boostTexts = this.enemyActiveBoosts.map(boost => {
                        const emoji = this.getBoostEmoji(boost.gene);
                        return `${emoji}${boost.description}`;
                    });
                    
                    boostDisplay.innerHTML = `Class Boosts:<br>${boostTexts.join('<br>')}`;
                    enemyTeamSection.style.position = 'relative';
                    enemyTeamSection.appendChild(boostDisplay);
                }
            }

            getBoostEmoji(gene) {
                const emojiMap = {
                    'Red': '🥀',
                    'Orange': '🔥',
                    'Yellow': '🌤️',
                    'Green': '🍃',
                    'Blue': '🌊',
                    'Purple': '🔮',
                    'Neutral': '🕊️',
                    'Splash': '🧹'
                };
                return emojiMap[gene] || '';
            }

            createBattleCharacterElement(character) {
                const div = document.createElement('div');
                div.className = 'battle-character';
                div.dataset.battleChar = character.id;
                div.dataset.team = character.isPlayer ? 'player' : 'enemy';
                
                if (character.hp <= 0) {
                    div.classList.add('defeated');
                }
                
                const currentChar = this.getCurrentCharacter();
                if (currentChar && currentChar.id === character.id) {
                    div.classList.add('active');
                }
                
                const sprite = document.createElement('div');
                sprite.className = 'battle-sprite';
                this.game.updateCharacterSprite(sprite, character);
                
                const stats = document.createElement('div');
                stats.className = 'character-stats';
                
                // Check if stats are modified by class boosts and apply colors
                const isHpModified = character.stats.maxHp !== character.baseStats.maxHp;
                const isAtkModified = character.stats.attack !== character.baseStats.attack;
                const isSpdModified = character.stats.speed !== character.baseStats.speed;
                
                const hpColor = isHpModified ? (character.stats.maxHp > character.baseStats.maxHp ? '#2e7d32' : '#c62828') : '';
                const atkColor = isAtkModified ? (character.stats.attack > character.baseStats.attack ? '#2e7d32' : '#c62828') : '';
                const spdColor = isSpdModified ? (character.stats.speed > character.baseStats.speed ? '#2e7d32' : '#c62828') : '';
                
                const hpStyle = hpColor ? `color: ${hpColor};` : '';
                const atkStyle = atkColor ? `color: ${atkColor};` : '';
                const spdStyle = spdColor ? `color: ${spdColor};` : '';
                
                stats.innerHTML = `
                    <div>${character.id}</div>
                    <div style="${hpStyle}">❤️ <strong>${character.hp}</strong>/${character.stats.maxHp}</div>
                    <div><span style="${atkStyle}">⚔️ ${character.stats.attack}</span> | <span style="${spdStyle}">⚡ ${character.stats.speed}</span></div>
                `;
                
                const healthBar = document.createElement('div');
                healthBar.className = 'health-bar';
                const healthFill = document.createElement('div');
                healthFill.className = 'health-fill';
                const healthPercent = (character.hp / character.stats.maxHp) * 100;
                healthFill.style.width = `${healthPercent}%`;
                healthBar.appendChild(healthFill);
                
                div.appendChild(sprite);
                div.appendChild(stats);
                div.appendChild(healthBar);
                
                return div;
            }

            updateTurnOrder() {
                const turnOrderList = document.getElementById('turnOrderList');
                turnOrderList.innerHTML = '';
                
                this.turnQueue.forEach((char, index) => {
                    const indicator = document.createElement('div');
                    indicator.className = 'turn-indicator';
                    indicator.classList.add(char.isPlayer ? 'player' : 'enemy');
                    
                    if (index === this.currentTurnIndex % this.turnQueue.length) {
                        indicator.classList.add('active');
                    }
                    
                    // Show gene emotes instead of text
                    if (char.genes.length === 1) {
                        indicator.textContent = GENE_SYMBOLS[char.genes[0]];
                    } else {
                        indicator.innerHTML = `<span style="font-size: 10px;">${GENE_SYMBOLS[char.genes[0]]}${GENE_SYMBOLS[char.genes[1]]}</span>`;
                    }
                    
                    turnOrderList.appendChild(indicator);
                });
            }

            updateBattleControls() {
                const currentChar = this.getCurrentCharacter();
                const controlsElement = document.getElementById('battleControls');
                const activeNameElement = document.getElementById('activeCharacterName');
                const attackButtonsElement = document.getElementById('attackButtons');
                
                if (!currentChar) return;
                
                // Update the existing header
                activeNameElement.textContent = currentChar.id;

                // Initialize battle controls event listeners only once
                this.initializeBattleControlsListeners();

                controlsElement.style.display = 'block';

                if (currentChar.isPlayer) {
                    this.setupPlayerControls(currentChar, attackButtonsElement);
                } else {
                    this.setupEnemyControls(attackButtonsElement);
                }
            }

            initializeBattleControlsListeners() {
                if (this.battleControlsInitialized) return;
                
                this.battleControlsInitialized = true;
                
                // Add event listeners to the existing header buttons
                const existingLogButton = document.getElementById('battleLogButton');
                const existingQuitButton = document.getElementById('quitBattleBtn');
                
                if (existingLogButton) {
                    existingLogButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const battleLogModal = document.getElementById('battleLogModal');
                        if (battleLogModal) {
                            battleLogModal.classList.add('show');
                            const currentLog = document.getElementById('battleLog').innerHTML;
                            const modalContent = document.getElementById('battleLogModalContent');
                            if (modalContent) {
                                modalContent.innerHTML = currentLog;
                                modalContent.scrollTop = modalContent.scrollHeight;
                            }
                        }
                    });
                }
                
                if (existingQuitButton) {
                    existingQuitButton.addEventListener('click', () => {
                        this.showQuitConfirmation();
                    });
                }
            }

            setupPlayerControls(currentChar, attackButtonsElement) {
                const isMobile = window.innerWidth <= 768;
                const currentCharAttack = this.selectedAttackGenes[currentChar.id];
                
                // Only set the player interface content (no header)
                attackButtonsElement.innerHTML = `
                    <div style="margin-bottom: 10px; color: #666; font-size: 14px; font-weight: 500; text-align: center;">Select an attack:</div>
                    <div id="attackRow" style="display: flex; gap: ${isMobile ? '8px' : '12px'}; justify-content: center; flex-wrap: wrap; margin-bottom: 12px;"></div>
                    <div style="margin-bottom: 8px; color: #666; font-size: 14px; font-weight: 500; text-align: center;">Select a target:</div>
                    <div id="targetRow" style="display: flex; gap: ${isMobile ? '6px' : '8px'}; justify-content: center; flex-wrap: wrap;"></div>
                `;
                
                const attackRow = document.getElementById('attackRow');
                const targetRow = document.getElementById('targetRow');
                
                this.createAttackButtons(currentChar, attackRow, currentCharAttack);
                this.createTargetButtons(currentChar, targetRow, currentCharAttack, isMobile);
            }

            setupEnemyControls(attackButtonsElement) {
                attackButtonsElement.innerHTML = '<div style="text-align: center; color: #666;">Enemy is thinking...</div>';
            }

            createAttackButtons(currentChar, attackRow, currentCharAttack) {
                const attackObjs = currentChar.getAttackGenes();
                const activeBoosts = currentChar.isPlayer ? this.playerActiveBoosts : this.enemyActiveBoosts;
                const hasNeutralBoost = activeBoosts && activeBoosts.some(boost => boost.gene === 'Neutral');
                
                attackObjs.forEach((attackObj) => {
                    const button = document.createElement('button');
                    button.className = 'attack-btn';
                    
                    // Handle selection highlighting
                    const isSelected = currentCharAttack && 
                        currentCharAttack.gene === attackObj.gene && 
                        currentCharAttack.type === attackObj.type;
                    
                    if (isSelected) {
                        button.classList.add('selected-attack');
                    }
                    
                    if (this.attackButtonsDisabled) {
                        button.disabled = true;
                    }
                    
                    // Set button text and styling
                    this.setAttackButtonContent(button, attackObj, hasNeutralBoost);
                    
                    button.addEventListener('click', () => {
                        // Immediate disable to prevent spam
                        button.disabled = true;
                        attackRow.querySelectorAll('button').forEach(btn => btn.disabled = true);
                        
                        this.selectedAttackGenes[currentChar.id] = attackObj;
                        this.updateBattleControls(); // Refresh to show selection and targets
                    });
                    
                    attackRow.appendChild(button);
                });
            }

            setAttackButtonContent(button, attackObj, hasNeutralBoost) {
                if (attackObj.type === 'splash') {
                    button.textContent = `${attackObj.gene} ⇶`;
                    button.style.setProperty('--attack-color', GENE_DARK_COLORS[attackObj.gene]);
                    button.style.setProperty('--attack-color-light', GENE_COLORS[attackObj.gene]);
                } else {
                    // Show ⇶ for Neutral attack when boost is active
                    if (attackObj.gene === 'Neutral' && hasNeutralBoost) {
                        button.textContent = 'Neutral ⇶';
                    } else {
                        button.textContent = attackObj.gene;
                    }
                    
                    if (attackObj.gene !== 'Neutral') {
                        button.style.setProperty('--attack-color', GENE_COLORS[attackObj.gene]);
                        button.style.setProperty('--attack-color-light', GENE_LIGHT_COLORS[attackObj.gene]);
                    } else {
                        button.style.setProperty('--attack-color', '#999');
                        button.style.setProperty('--attack-color-light', '#bbb');
                    }
                }
            }

            createTargetButtons(currentChar, targetRow, currentCharAttack, isMobile) {
                if (!currentCharAttack) return;
                
                if (currentCharAttack.type === 'splash') {
                    this.createSplashTargetButtons(targetRow, currentCharAttack, isMobile);
                } else {
                    this.createSingleTargetButtons(targetRow, currentCharAttack, isMobile);
                }
            }

            createSplashTargetButtons(targetRow, currentCharAttack, isMobile) {
                const availableTargets = this.enemyTeam.filter(char => char.hp > 0);
                
                if (availableTargets.length === 0) return;
                
                availableTargets.forEach(target => {
                    const button = this.createTargetButton(target, isMobile, true, currentCharAttack);
                    
                    button.addEventListener('click', async () => {
                        if (this.isProcessingTurn) return;
                        
                        const allButtons = document.querySelectorAll('.attack-btn');
                        allButtons.forEach(btn => btn.disabled = true);
                        
                        this.processTurn(currentCharAttack, null);
                    });
                    
                    targetRow.appendChild(button);
                });
            }

            createSingleTargetButtons(targetRow, currentCharAttack, isMobile) {
                const availableTargets = this.enemyTeam.filter(char => char.hp > 0);
                
                availableTargets.forEach(target => {
                    const button = this.createTargetButton(target, isMobile, false, currentCharAttack);
                    
                    button.addEventListener('click', async () => {
                        if (this.isProcessingTurn) return;
                        
                        const allButtons = document.querySelectorAll('.attack-btn');
                        allButtons.forEach(btn => btn.disabled = true);
                        
                        await this.showAttackAnimation(this.getCurrentCharacter(), target);
                        this.processTurn(currentCharAttack, target);
                    });
                    
                    targetRow.appendChild(button);
                });
            }

            createTargetButton(target, isMobile, isSplash = false, attackObj = null) {
                const button = document.createElement('button');
                button.className = 'attack-btn';
                
                // Set button appearance based on target genes
                if (target.genes.length === 1) {
                    button.style.background = `linear-gradient(45deg, ${GENE_COLORS[target.genes[0]]}, ${GENE_LIGHT_COLORS[target.genes[0]]})`;
                } else if (target.genes[0] === target.genes[1]) {
                    const geneColor = GENE_COLORS[target.genes[0]];
                    const darkColor = GENE_DARK_COLORS[target.genes[0]];
                    button.style.background = `linear-gradient(45deg, ${geneColor}, ${darkColor}, ${geneColor})`;
                } else {
                    button.style.background = `linear-gradient(45deg, ${GENE_COLORS[target.genes[0]]}, ${GENE_COLORS[target.genes[1]]})`;
                }
                
                button.textContent = target.id;
                button.style.color = 'white';
                button.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.7)';
                
                // Responsive sizing
                if (isMobile) {
                    button.style.fontSize = '12px';
                    button.style.padding = '10px 8px';
                }
                
                return button;
            }

            selectAttackGene(attackObj) {
                // Prevent selecting attack if already processing a turn or buttons are disabled
                if (this.isProcessingTurn || this.attackButtonsDisabled) {
                    return;
                }
                
                // Disable attack buttons immediately after clicking
                this.attackButtonsDisabled = true;
                this.updateBattleControls(); // Refresh the UI to show disabled state
                
                this.selectedAttackObj = attackObj;
                
                // For splash attacks, execute immediately without target selection
                if (attackObj.type === 'splash') {
                    this.processTurn(attackObj, null);
                } else {
                    this.showTargetSelection();
                }
            }

            showTargetSelection() {
                const attackButtonsElement = document.getElementById('attackButtons');
                
                const availableTargets = this.enemyTeam.filter(char => char.hp > 0);
                
                attackButtonsElement.innerHTML = '<div style="margin-bottom: 15px; color: #666; font-weight: bold; text-align: center; padding: 0 10px;">Select a target:</div>';
                
                const targetContainer = document.createElement('div');
                targetContainer.style.display = 'flex';
                
                // Mobile-optimized gap for target container
                const isMobile = window.innerWidth <= 768;
                targetContainer.style.gap = isMobile ? '6px' : '8px';
                
                targetContainer.style.justifyContent = 'center';
                targetContainer.style.flexWrap = 'wrap';
                targetContainer.style.width = '100%';
                
                availableTargets.forEach(target => {
                    const button = document.createElement('button');
                    button.className = 'attack-btn';

                    // Use target's gene colors for the button
                    if (target.genes.length === 1) {
                        button.style.background = `linear-gradient(45deg, ${GENE_COLORS[target.genes[0]]}, ${GENE_LIGHT_COLORS[target.genes[0]]})`;
                    } else if (target.genes[0] === target.genes[1]) {
                        const geneColor = GENE_COLORS[target.genes[0]];
                        const darkColor = GENE_DARK_COLORS[target.genes[0]];
                        button.style.background = `linear-gradient(45deg, ${geneColor}, ${darkColor}, ${geneColor})`;
                    } else {
                        button.style.background = `linear-gradient(45deg, ${GENE_COLORS[target.genes[0]]}, ${GENE_COLORS[target.genes[1]]})`;
                    }
                    
                    button.textContent = target.id;
                    button.style.color = 'white';
                    button.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.7)';
                    
                    // Mobile-optimized sizing for target buttons
                    const isMobile = window.innerWidth <= 768;
                    if (isMobile) {
                        button.style.minWidth = '100px';
                        button.style.maxWidth = '120px';
                        button.style.flex = '1 1 100px';
                        button.style.fontSize = '12px';
                        button.style.padding = '10px 12px';
                    } else {
                        button.style.minWidth = '120px';
                        button.style.maxWidth = '140px';
                        button.style.flex = '1 1 120px';
                    }
                    
                    button.addEventListener('click', async () => {
                        // Prevent multiple clicks during turn processing
                        if (this.isProcessingTurn) {
                            return;
                        }
                        
                        // Disable all target buttons immediately after clicking
                        const allTargetButtons = targetContainer.querySelectorAll('button');
                        allTargetButtons.forEach(btn => btn.disabled = true);
                        
                        await this.showAttackAnimation(this.getCurrentCharacter(), target);
                        this.processTurn(this.selectedAttackObj, target);
                    });
                    
                    targetContainer.appendChild(button);
                });
                
                attackButtonsElement.appendChild(targetContainer);
            }

            handlePlayerAttack(attackGene) {
                const availableTargets = this.enemyTeam.filter(char => char.hp > 0);
                if (availableTargets.length === 0) return;
                
                // For now, attack a random target (could be enhanced with target selection)
                const target = availableTargets[Math.floor(Math.random() * availableTargets.length)];
                this.processTurn(attackGene, target);
            }
        }

        class FusionGame {
            constructor() {
                this.characters = this.generateCharacters();
                this.selectedCharacters = [];
                this.botActive = false;
                this.speedMultiplier = 1;
                this.botInterval = null;
                this.victoryShown = false;
                this.selectedBattleTeam = [];
                this.battleSystem = new BattleSystem(this);
                this.init();
            }

            showCharacterInfo(characterId) {
                const character = this.characters[characterId];
                if (!character || !character.unlocked) return;
                
                const popup = document.getElementById('characterInfoPopup');
                
                // Update basic character info
                this.updateCharacterBasicInfo(character);
                
                // Clean up any previous layout
                this.cleanupCharacterInfoLayout(popup);
                
                // Create new compact layout
                this.createCompactCharacterLayout(character, popup);
                
                // Update attacks section
                this.updateCharacterAttacks(character);
                
                // Hide old effectiveness section
                const effectivenessSection = popup.querySelector('.info-effectiveness');
                if (effectivenessSection) {
                    effectivenessSection.style.display = 'none';
                }
                
                popup.classList.add('show');
            }

            updateCharacterBasicInfo(character) {
                const sprite = document.getElementById('infoCharacterSprite');
                const name = document.getElementById('infoCharacterName');
                const hp = document.getElementById('infoHp');
                const atk = document.getElementById('infoAtk');
                const spd = document.getElementById('infoSpd');
                
                this.updateCharacterSprite(sprite, character);
                name.textContent = character.id;
                hp.textContent = character.stats.hp;
                atk.textContent = character.stats.attack;
                spd.textContent = character.stats.speed;
            }

            cleanupCharacterInfoLayout(popup) {
                // Remove all previous layout modifications
                const elementsToRemove = [
                    '.info-top-container',
                    '.info-top-row', 
                    '.info-class-boosts-horizontal',
                    '.info-layout-top',
                    '.info-class-boosts'
                ];
                
                elementsToRemove.forEach(selector => {
                    const element = popup.querySelector(selector);
                    if (element) element.remove();
                });
                
                // Reset any inline styles
                const infoDisplay = popup.querySelector('.info-character-display');
                const statsGrid = popup.querySelector('.info-stats-grid');
                if (infoDisplay) infoDisplay.style.cssText = '';
                if (statsGrid) statsGrid.style.cssText = '';
            }

            createCompactCharacterLayout(character, popup) {
                const attacksSection = popup.querySelector('.info-attacks');
                
                // Row 1: Sprite+Name and Class Boosts side by side
                const topRow = document.createElement('div');
                topRow.className = 'info-compact-top';
                topRow.style.cssText = 'display: flex; gap: 20px; margin-bottom: 15px; align-items: flex-start;';
                
                // Left: Sprite + Name (compact)
                const spriteNameSection = this.createSpriteNameSection();
                
                // Right: Class Boosts
                const classBoostsSection = this.createClassBoostsSection(character);
                
                topRow.appendChild(spriteNameSection);
                topRow.appendChild(classBoostsSection);
                
                // Row 2: Stats Grid (full width)
                const statsRow = this.createFullWidthStatsRow();
                
                // Insert before attacks
                attacksSection.parentNode.insertBefore(topRow, attacksSection);
                attacksSection.parentNode.insertBefore(statsRow, attacksSection);
            }

            createSpriteNameSection() {
                const infoDisplay = document.querySelector('.info-character-display');
                const container = document.createElement('div');
                container.style.cssText = 'display: flex; flex-direction: column; align-items: center; min-width: 120px;';
                container.appendChild(infoDisplay);
                return container;
            }

            createClassBoostsSection(character) {
                const container = document.createElement('div');
                container.className = 'info-class-boosts-compact';
                container.style.cssText = 'flex: 1; padding: 12px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #4ecdc4;';
                
                const contributions = character.getClassBoostContribution();
                let html = '<h4 style="margin: 0 0 8px 0; color: #666; font-size: 14px;">Class Boosts:</h4>';
                
                for (const [gene, count] of Object.entries(contributions)) {
                    if (CLASS_BOOSTS[gene]) {
                        const emoji = this.battleSystem.getBoostEmoji(gene);
                        html += `<div style="margin: 4px 0; font-size: 12px;">
                            <strong>${gene}:</strong> ${count} point${count > 1 ? 's' : ''} 
                            <span style="color: #4ecdc4;">${emoji}${CLASS_BOOSTS[gene].description}</span>
                        </div>`;
                    }
                }
                
                html += '<div style="font-size: 10px; color: #999; margin-top: 6px; font-style: italic;">Need 3+ points to activate (max 2 boosts)</div>';
                container.innerHTML = html;
                
                return container;
            }

            createFullWidthStatsRow() {
                const statsGrid = document.querySelector('.info-stats-grid');
                const container = document.createElement('div');
                container.style.cssText = 'width: 100%; margin-bottom: 20px;';
                
                // Modify stats grid to be horizontal
                statsGrid.style.cssText = 'display: flex; gap: 15px; justify-content: center;';
                
                // Make stat cards smaller for horizontal layout
                const statCards = statsGrid.querySelectorAll('.info-stat-card');
                statCards.forEach(card => {
                    card.style.cssText += 'min-width: 80px; text-align: center;';
                });
                
                container.appendChild(statsGrid);
                
                // Mobile responsive
                const isMobile = window.innerWidth <= 768;
                if (isMobile) {
                    statsGrid.style.flexDirection = 'column';
                    statsGrid.style.alignItems = 'center';
                }
                
                return container;
            }

            updateCharacterAttacks(character) {
                const attacksList = document.getElementById('infoAttacksList');
                const attacks = character.getAttackGenes();
                
                attacksList.innerHTML = attacks.map(attack => {
                    let effectivenessHtml = '';
                    
                    if (attack.gene !== 'Neutral') {
                        const genes = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Purple'];
                        effectivenessHtml = `
                            <div style="margin-top: 8px; font-size: 11px;">
                                <div style="margin-bottom: 4px; font-weight: bold;">vs:</div>
                                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 2px;">
                                    ${genes.map(defendGene => {
                                        const effectiveness = character.getEffectiveness(attack.gene, {genes: [defendGene]});
                                        let className = 'normal';
                                        let text = '1.0×';
                                        
                                        if (effectiveness === 1.5) { className = 'super'; text = '1.5×'; }
                                        else if (effectiveness === 1.25) { className = 'effective'; text = '1.25×'; }
                                        else if (effectiveness === 0.75) { className = 'weak'; text = '0.75×'; }
                                        else if (effectiveness === 0.5) { className = 'very-weak'; text = '0.5×'; }
                                        
                                        return `<div class="effectiveness-cell ${className}" style="padding: 2px; text-align: center;">
                                            ${GENE_SYMBOLS[defendGene]}<br><span style="font-size: 9px;">${text}</span>
                                        </div>`;
                                    }).join('')}
                                </div>
                            </div>
                        `;
                    }
                    
                    const attackName = attack.type === 'splash' ? `${attack.gene} ⇶` : attack.gene;
                    const attackDesc = attack.type === 'splash' ? ' (hits all enemies for 50% damage)' : ' (single target)';
                    
                    return `<div style="margin-bottom: 12px; padding: 10px; background: #f0f0f0; border-radius: 8px;">
                        <strong>${attackName}</strong>${attackDesc}
                        ${effectivenessHtml}
                    </div>`;
                }).join('');
            }

            setupCharacterDoubleClick() {
                // Track click timing for battle selection
                this.clickTimeouts = new Map();
                
                // For fusion table and selected team display
                document.addEventListener('dblclick', (e) => {
                    const slot = e.target.closest('.character-slot');
                    if (slot && slot.dataset.characterId) {
                        const character = this.characters[slot.dataset.characterId];
                        if (character && character.unlocked) {
                            this.showCharacterInfo(slot.dataset.characterId);
                        }
                    }
                    
                    // For battle character selection grid and selected team display
                    const selectionSlot = e.target.closest('.selection-slot');
                    const selectedTeamSlot = e.target.closest('.selected-team-grid .character-slot');

                    if (selectionSlot || selectedTeamSlot) {
                        const sprite = (selectionSlot || selectedTeamSlot).querySelector('.character-sprite');
                        if (sprite && !sprite.classList.contains('locked-sprite')) {
                            // Build sprite map if needed
                            this.buildSpriteMap();
                            
                            // Fast lookup using cached sprite map
                            const characterId = this.spriteMap.get(sprite.innerHTML);
                            if (characterId) {
                                this.showCharacterInfo(characterId);
                            }
                        }
                    }
                });
                
                // Handle single clicks for battle selection with delay to allow double-click
                document.addEventListener('click', (e) => {
                    const selectionSlot = e.target.closest('.selection-slot');
                    if (selectionSlot) {
                        const sprite = selectionSlot.querySelector('.character-sprite');
                        if (sprite && !sprite.classList.contains('locked-sprite')) {
                            this.buildSpriteMap();
                            const characterId = this.spriteMap.get(sprite.innerHTML);
                            if (characterId) {
                                // Clear any existing timeout for this slot
                                if (this.clickTimeouts.has(selectionSlot)) {
                                    clearTimeout(this.clickTimeouts.get(selectionSlot));
                                }
                                
                                // Set timeout for single click action
                                const timeout = setTimeout(() => {
                                    this.toggleBattleTeamSelection(characterId);
                                    this.clickTimeouts.delete(selectionSlot);
                                }, 250); // 250ms delay for single click
                                
                                this.clickTimeouts.set(selectionSlot, timeout);
                            }
                        }
                    }
                });
                
                // Close popup listeners
                document.getElementById('infoCloseBtn').addEventListener('click', () => {
                    document.getElementById('characterInfoPopup').classList.remove('show');
                });
                
                document.getElementById('characterInfoPopup').addEventListener('click', (e) => {
                    if (e.target.id === 'characterInfoPopup') {
                        document.getElementById('characterInfoPopup').classList.remove('show');
                    }
                });
            }

            unlockAllCharacters() {
                Object.values(this.characters).forEach(character => {
                    if (!character.unlocked) {
                        character.unlocked = true;
                    }
                });
                
                // Recreate the table to update all slots
                this.createTable();
                this.updateDisplay();
                this.updateBattleTeamSelection();
                
                // Show victory message
                this.victoryShown = true;
                setTimeout(() => this.showVictory(), 500);
            }

            generateCharacters() {
                const characters = {};
                
                // Single gene characters (unlocked by default)
                GENES.forEach(gene => {
                    characters[gene] = new GameCharacter(gene, [gene], true);
                });

                // Double gene characters (locked by default)
                GENES.forEach((primary, i) => {
                    GENES.forEach((secondary, j) => {
                        const id = `${primary}-${secondary}`;
                        characters[id] = new GameCharacter(id, [primary, secondary], false);
                    });
                });

                return characters;
            }

            init() {
                this.setupTabNavigation();
                this.createTable();
                this.updateDisplay();
                this.setupEventListeners();
                this.updateBattleTeamSelection();
                this.setupCharacterDoubleClick();
            }

            setupTabNavigation() {
                const tabButtons = document.querySelectorAll('.tab-button');
                const tabContents = document.querySelectorAll('.tab-content');
                
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const targetTab = button.dataset.tab;
                        
                        // Update active tab button
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                        
                        // Update active tab content
                        tabContents.forEach(content => {
                            if (content.id === `${targetTab}-tab`) {
                                content.classList.add('active');
                            } else {
                                content.classList.remove('active');
                            }
                        });
                        
                        // Update battle team selection when switching to battle tab
                        if (targetTab === 'battle') {
                            this.updateBattleTeamSelection();
                        }
                    });
                });
            }

            createTable() {
                const table = document.getElementById('fusionTable');
                table.innerHTML = '';

                // Create 7x6 grid: 6 columns for double genes + 1 column for singles
                for (let row = 0; row < 6; row++) {
                    // Double gene slots (6 columns)
                    for (let col = 0; col < 6; col++) {
                        const primary = GENES[col];
                        const secondary = GENES[row];
                        const id = `${primary}-${secondary}`;
                        this.createCharacterSlot(table, id);
                    }
                    
                    // Single gene slot (7th column)
                    const singleGene = GENES[row];
                    this.createCharacterSlot(table, singleGene);
                }
            }

            createCharacterSlot(container, characterId) {
                const character = this.characters[characterId];
                const slot = document.createElement('div');
                slot.className = `character-slot ${character.unlocked ? 'unlocked' : 'locked'}`;
                slot.dataset.characterId = characterId;

                const sprite = document.createElement('div');
                sprite.className = 'character-sprite';
                
                this.updateCharacterSprite(sprite, character);

                slot.appendChild(sprite);
                container.appendChild(slot);

                if (character.unlocked) {
                    slot.addEventListener('click', () => this.selectCharacter(characterId));
                }
            }

            updateCharacterSprite(sprite, character) {
                if (character.unlocked) {
                    if (character.genes.length === 1) {
                        sprite.className = sprite.className.replace(/single-gene|double-gene|same-gene|different-genes|locked-sprite/g, '').trim();
                        sprite.className += ' single-gene';
                        sprite.style.setProperty('--gene-color', GENE_COLORS[character.genes[0]]);
                        sprite.textContent = character.symbol;
                        sprite.innerHTML = character.symbol;
                    } else {
                        sprite.className = sprite.className.replace(/single-gene|double-gene|same-gene|different-genes|locked-sprite/g, '').trim();
                        sprite.className += ' double-gene';
                        
                        const isSameGene = character.genes[0] === character.genes[1];
                        if (isSameGene) {
                            sprite.classList.add('same-gene');
                            const geneColor = GENE_COLORS[character.genes[0]];
                            const darkColor = GENE_DARK_COLORS[character.genes[0]];
                            sprite.style.setProperty('--same-gene-gradient', 
                                `linear-gradient(45deg, ${geneColor}, ${darkColor}, ${geneColor})`);
                        } else {
                            sprite.classList.add('different-genes');
                            sprite.style.setProperty('--primary-color', GENE_COLORS[character.genes[0]]);
                            sprite.style.setProperty('--secondary-color', GENE_COLORS[character.genes[1]]);
                        }
                        
                        sprite.innerHTML = '';
                        const emoji1 = document.createElement('span');
                        emoji1.className = 'gene-emoji';
                        emoji1.textContent = GENE_SYMBOLS[character.genes[0]];
                        
                        const emoji2 = document.createElement('span');
                        emoji2.className = 'gene-emoji';
                        emoji2.textContent = GENE_SYMBOLS[character.genes[1]];
                        
                        sprite.appendChild(emoji1);
                        sprite.appendChild(emoji2);
                    }
                } else {
                    sprite.className = sprite.className.replace(/single-gene|double-gene|same-gene|different-genes/g, '').trim();
                    sprite.className += ' locked-sprite';
                    sprite.textContent = '?';
                    sprite.innerHTML = '?';
                    sprite.style.removeProperty('--gene-color');
                    sprite.style.removeProperty('--primary-color');
                    sprite.style.removeProperty('--secondary-color');
                    sprite.style.removeProperty('--same-gene-gradient');
                }
            }

            buildSpriteMap() {
                if (!this.spriteMap) {
                    this.spriteMap = new Map();
                    Object.values(this.characters).forEach(char => {
                        if (char.unlocked) {
                            const testSprite = document.createElement('div');
                            this.updateCharacterSprite(testSprite, char);
                            this.spriteMap.set(testSprite.innerHTML, char.id);
                        }
                    });
                }
            }

            rebuildSpriteMap() {
                this.spriteMap = null;
                this.buildSpriteMap();
            }

            selectCharacter(characterId) {
                const character = this.characters[characterId];
                if (!character.unlocked || this.botActive) return;

                if (this.selectedCharacters.includes(characterId)) {
                    this.selectedCharacters = this.selectedCharacters.filter(id => id !== characterId);
                } else if (this.selectedCharacters.length < 2) {
                    this.selectedCharacters.push(characterId);
                } else {
                    this.selectedCharacters[0] = this.selectedCharacters[1];
                    this.selectedCharacters[1] = characterId;
                }

                this.updateDisplay();
            }

            updateDisplay() {
                // Update character slot selection states
                document.querySelectorAll('.character-slot').forEach(slot => {
                    const characterId = slot.dataset.characterId;
                    if (this.selectedCharacters.includes(characterId)) {
                        slot.classList.add('selected');
                    } else {
                        slot.classList.remove('selected');
                    }
                });

                // Update parent displays
                this.updateParentDisplay('parent1Display', this.selectedCharacters[0]);
                this.updateParentDisplay('parent2Display', this.selectedCharacters[1]);

                // Update fuse button
                const fuseBtn = document.getElementById('fuseBtn');
                if (this.botActive) {
                    fuseBtn.disabled = true;
                    fuseBtn.textContent = 'Bot is in Control';
                } else if (this.selectedCharacters.length === 2) {
                    fuseBtn.disabled = false;
                    fuseBtn.textContent = 'Fuse Creatures';
                } else {
                    fuseBtn.disabled = true;
                    fuseBtn.textContent = 'Select Two Creatures to Fuse';
                }

                // Update progress
                const unlockedCount = Object.values(this.characters).filter(c => c.unlocked).length;
                const totalCount = Object.keys(this.characters).length;
                const progress = (unlockedCount / totalCount) * 100;
                
                document.getElementById('progressFill').style.width = `${progress}%`;
                document.getElementById('unlockedCount').textContent = unlockedCount;

                // Check for victory
                if (unlockedCount === totalCount && !this.victoryShown) {
                    this.victoryShown = true;
                    setTimeout(() => this.showVictory(), 1000);
                }
            }

            updateParentDisplay(displayId, characterId) {
                const display = document.getElementById(displayId);
                const sprite = display.querySelector('.character-sprite');
                
                if (characterId && this.characters[characterId]) {
                    const character = this.characters[characterId];
                    this.updateCharacterSprite(sprite, character);
                } else {
                    sprite.textContent = '?';
                    sprite.innerHTML = '?';
                    sprite.className = 'character-sprite locked-sprite';
                    sprite.style.removeProperty('--gene-color');
                    sprite.style.removeProperty('--primary-color');
                    sprite.style.removeProperty('--secondary-color');
                    sprite.style.removeProperty('--same-gene-gradient');
                }
            }

            updateBattleTeamSelection() {
                const selectionGrid = document.getElementById('battleCharacterSelection');
                const selectedTeamDisplay = document.getElementById('selectedTeamDisplay');
                const startBattleBtn = document.getElementById('startBattleBtn');
                
                if (!selectionGrid) return;
                
                // Clear existing content
                selectionGrid.innerHTML = '';
                
                // Add unlocked characters to selection
                const unlockedChars = Object.values(this.characters).filter(char => char.unlocked);
                unlockedChars.forEach(character => {
                    const slot = document.createElement('div');
                    slot.className = 'selection-slot';
                    if (this.selectedBattleTeam.includes(character.id)) {
                        slot.classList.add('selected');
                    }
                    
                    const sprite = document.createElement('div');
                    sprite.className = 'character-sprite';
                    this.updateCharacterSprite(sprite, character);
                    
                    slot.appendChild(sprite);
                    selectionGrid.appendChild(slot);
                });
                
                // Update selected team display with removal buttons
                selectedTeamDisplay.innerHTML = '';
                this.selectedBattleTeam.forEach(charId => {
                    const character = this.characters[charId];
                    const slot = document.createElement('div');
                    slot.className = 'character-slot unlocked';
                    slot.style.position = 'relative';
                    
                    const sprite = document.createElement('div');
                    sprite.className = 'character-sprite';
                    this.updateCharacterSprite(sprite, character);
                    
                    // Add X button for removal
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '×';
                    removeBtn.style.cssText = `
                        position: absolute;
                        top: -5px;
                        right: -5px;
                        width: 20px;
                        height: 20px;
                        border-radius: 50%;
                        background: #ff6b6b;
                        color: white;
                        border: none;
                        font-size: 12px;
                        font-weight: bold;
                        cursor: pointer;
                        z-index: 10;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    removeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.selectedBattleTeam = this.selectedBattleTeam.filter(id => id !== charId);
                        this.updateBattleTeamSelection();
                    });
                    
                    slot.appendChild(sprite);
                    slot.appendChild(removeBtn);
                    selectedTeamDisplay.appendChild(slot);
                });
                
                // Add empty slots
                for (let i = this.selectedBattleTeam.length; i < 3; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'character-slot locked';
                    const sprite = document.createElement('div');
                    sprite.className = 'character-sprite locked-sprite';
                    sprite.textContent = '?';
                    slot.appendChild(sprite);
                    selectedTeamDisplay.appendChild(slot);
                }
                
                // Update start battle button
                if (this.selectedBattleTeam.length === 3) {
                    startBattleBtn.disabled = false;
                    startBattleBtn.textContent = 'Start Battle!';
                } else {
                    startBattleBtn.disabled = true;
                    startBattleBtn.textContent = `Select ${3 - this.selectedBattleTeam.length} more creature${3 - this.selectedBattleTeam.length !== 1 ? 's' : ''} to Start Battle`;
                }
            }

            toggleBattleTeamSelection(characterId) {
                if (this.selectedBattleTeam.includes(characterId)) {
                    this.selectedBattleTeam = this.selectedBattleTeam.filter(id => id !== characterId);
                } else if (this.selectedBattleTeam.length < 3) {
                    this.selectedBattleTeam.push(characterId);
                }
                
                this.updateBattleTeamSelection();
            }

            selectRandomTeam() {
                // Get all unlocked characters
                const unlockedCharacters = Object.values(this.characters).filter(char => char.unlocked);
                
                if (unlockedCharacters.length < 3) {
                    alert('You need at least 3 unlocked characters to use random selection!');
                    return;
                }
                
                // Clear current selection
                this.selectedBattleTeam = [];
                
                // Randomly select 3 different characters
                const shuffled = [...unlockedCharacters].sort(() => 0.5 - Math.random());
                this.selectedBattleTeam = shuffled.slice(0, 3).map(char => char.id);
                
                this.updateBattleTeamSelection();
            }

            startBattle() {
                if (this.selectedBattleTeam.length !== 3) return;
                
                // Difficulty is already set via the buttons, so just start the battle
                const playerTeam = this.selectedBattleTeam.map(id => this.characters[id]);
                this.battleSystem.setupBattle(playerTeam);
            }

            fuse() {
                if (this.selectedCharacters.length !== 2) return;

                const parent1 = this.characters[this.selectedCharacters[0]];
                const parent2 = this.characters[this.selectedCharacters[1]];

                const possibleOffspring = this.getPossibleOffspring(parent1, parent2);
                const lockedOffspring = possibleOffspring.filter(id => !this.characters[id].unlocked);

                this.startFusionAnimation(possibleOffspring, lockedOffspring);
            }

            startFusionAnimation(possibleOffspring, lockedOffspring) {
                const fuseBtn = document.getElementById('fuseBtn');
                const preview = document.getElementById('fusionPreview');
                const previewChar = document.getElementById('previewCharacter');
                
                const actualResult = lockedOffspring.length > 0 ? 
                    lockedOffspring[Math.floor(Math.random() * lockedOffspring.length)] : 
                    possibleOffspring[Math.floor(Math.random() * possibleOffspring.length)];
                
                fuseBtn.disabled = true;
                fuseBtn.classList.add('fusion');
                fuseBtn.textContent = 'Fusion...';
                
                preview.classList.add('show');
                
                let animationStep = 0;
                const totalSteps = Math.floor(20 / this.speedMultiplier);
                const animationSpeed = Math.floor(150 / this.speedMultiplier);
                
                const animationInterval = setInterval(() => {
                    let displayCharacter;
                    if (animationStep < totalSteps - 3) {
                        const randomOffspring = possibleOffspring[Math.floor(Math.random() * possibleOffspring.length)];
                        displayCharacter = this.characters[randomOffspring];
                    } else {
                        displayCharacter = this.characters[actualResult];
                    }
                    
                    this.updatePreviewCharacter(previewChar, displayCharacter);
                    this.createFusionSparkles(previewChar, this.speedMultiplier > 1);
                    
                    animationStep++;
                    
                    if (animationStep >= totalSteps) {
                        clearInterval(animationInterval);
                        this.showFinalResult(actualResult, lockedOffspring);
                    }
                }, animationSpeed);
            }

            updatePreviewCharacter(previewChar, character) {
                previewChar.className = 'preview-character';
                
                if (character.genes.length === 1) {
                    previewChar.className += ' single-gene';
                    previewChar.style.setProperty('--gene-color', GENE_COLORS[character.genes[0]]);
                    previewChar.textContent = character.symbol;
                    previewChar.innerHTML = character.symbol;
                } else {
                    const isSameGene = character.genes[0] === character.genes[1];
                    previewChar.className += ' double-gene';
                    
                    if (isSameGene) {
                        previewChar.classList.add('same-gene');
                        const geneColor = GENE_COLORS[character.genes[0]];
                        const darkColor = GENE_DARK_COLORS[character.genes[0]];
                        previewChar.style.setProperty('--same-gene-gradient', 
                            `linear-gradient(45deg, ${geneColor}, ${darkColor}, ${geneColor})`);
                    } else {
                        previewChar.classList.add('different-genes');
                        previewChar.style.setProperty('--primary-color', GENE_COLORS[character.genes[0]]);
                        previewChar.style.setProperty('--secondary-color', GENE_COLORS[character.genes[1]]);
                    }
                    
                    previewChar.innerHTML = '';
                    const emoji1 = document.createElement('span');
                    emoji1.className = 'gene-emoji';
                    emoji1.textContent = GENE_SYMBOLS[character.genes[0]];
                    
                    const emoji2 = document.createElement('span');
                    emoji2.className = 'gene-emoji';
                    emoji2.textContent = GENE_SYMBOLS[character.genes[1]];
                    
                    previewChar.appendChild(emoji1);
                    previewChar.appendChild(emoji2);
                }
            }

            showFinalResult(actualResult, lockedOffspring) {
                const previewChar = document.getElementById('previewCharacter');
                const resultCharacter = this.characters[actualResult];
                
                const sunshine = document.createElement('div');
                sunshine.className = 'sunshine-effect';
                previewChar.appendChild(sunshine);
                
                this.updatePreviewCharacter(previewChar, resultCharacter);
                
                setTimeout(() => {
                    sunshine.remove();
                    this.finishFusion(lockedOffspring, actualResult);
                }, Math.floor(2000 / this.speedMultiplier));
            }

            createFusionSparkles(container, isFastMode = false) {
                const sparkleCount = isFastMode ? 3 : 5;
                const duration = isFastMode ? Math.floor(400 / this.speedMultiplier) : Math.floor(800 / this.speedMultiplier);
                
                for (let i = 0; i < sparkleCount; i++) {
                    setTimeout(() => {
                        const sparkle = document.createElement('div');
                        sparkle.className = 'fusion-sparkle';
                        
                        const angle = (Math.PI * 2 * i) / sparkleCount;
                        const radius = 60 + Math.random() * 20;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        sparkle.style.left = `${50 + (x / 150) * 100}%`;
                        sparkle.style.top = `${50 + (y / 150) * 100}%`;
                        sparkle.style.background = `hsl(${Math.random() * 360}, 100%, 80%)`;
                        
                        container.appendChild(sparkle);
                        
                        const animation = sparkle.animate([
                            { transform: 'scale(0) rotate(0deg)', opacity: 1 },
                            { transform: 'scale(1) rotate(180deg)', opacity: 1, offset: 0.5 },
                            { transform: 'scale(0) rotate(360deg)', opacity: 0 }
                        ], {
                            duration: duration,
                            easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                        });
                        
                        animation.onfinish = () => sparkle.remove();
                    }, i * Math.floor((isFastMode ? 25 : 50) / this.speedMultiplier));
                }
            }

            finishFusion(lockedOffspring, actualResult) {
                const fuseBtn = document.getElementById('fuseBtn');
                const preview = document.getElementById('fusionPreview');
                
                setTimeout(() => {
                    preview.classList.remove('show');
                    
                    if (lockedOffspring.length > 0 && actualResult) {
                        this.unlockCharacter(actualResult);
                        this.createParticleEffect();
                    }

                    fuseBtn.classList.remove('fusion');
                    fuseBtn.disabled = false;
                    
                    this.selectedCharacters = [];
                    this.updateDisplay();
                }, 500);
            }

            getPossibleOffspring(parent1, parent2) {
                const offspring = [];
                
                parent1.genes.forEach(gene1 => {
                    parent2.genes.forEach(gene2 => {
                        const combo1 = `${gene1}-${gene2}`;
                        const combo2 = `${gene2}-${gene1}`;
                        
                        if (!offspring.includes(combo1)) {
                            offspring.push(combo1);
                        }
                        if (!offspring.includes(combo2) && combo1 !== combo2) {
                            offspring.push(combo2);
                        }
                    });
                });

                return offspring;
            }

            unlockCharacter(characterId) {
                this.characters[characterId].unlocked = true;
                
                const slot = document.querySelector(`[data-character-id="${characterId}"]`);
                if (slot) {
                    slot.classList.remove('locked');
                    slot.classList.add('unlocked', 'new-discovery');
                    
                    const sprite = slot.querySelector('.character-sprite');
                    const character = this.characters[characterId];
                    
                    this.updateCharacterSprite(sprite, character);

                    slot.addEventListener('click', () => this.selectCharacter(characterId));
                    setTimeout(() => slot.classList.remove('new-discovery'), 800);
                }
                this.rebuildSpriteMap();
            }

            createParticleEffect() {
                const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#a8e6cf', '#ff8b94', '#b4a7d6'];
                
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = 'particle';
                        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                        particle.style.left = Math.random() * window.innerWidth + 'px';
                        particle.style.top = Math.random() * window.innerHeight + 'px';

                        document.body.appendChild(particle);

                        const animation = particle.animate([
                            { transform: 'translateY(0px) scale(1)', opacity: 1 },
                            { transform: 'translateY(-100px) scale(0)', opacity: 0 }
                        ], {
                            duration: 2000,
                            easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                        });

                        animation.onfinish = () => particle.remove();
                    }, i * 50);
                }
            }

            showVictory() {
                const victoryMessage = document.getElementById('victoryMessage');
                victoryMessage.classList.add('show');
                
                // Auto-hide after 4 seconds
                setTimeout(() => {
                    victoryMessage.classList.remove('show');
                }, 4000);
            }

            setupEventListeners() {
                document.getElementById('fuseBtn').addEventListener('click', () => this.fuse());
                document.getElementById('botToggle').addEventListener('change', (e) => this.toggleBot(e.target.checked));
                document.getElementById('resetButton').addEventListener('click', () => this.showResetConfirmation());
                document.getElementById('confirmReset').addEventListener('click', () => this.confirmReset());
                document.getElementById('cancelReset').addEventListener('click', () => this.cancelReset());
                document.getElementById('startBattleBtn').addEventListener('click', () => this.startBattle());
                document.getElementById('unlockAllBtn').addEventListener('click', () => this.unlockAllCharacters());
                document.getElementById('randomSelectBtn').addEventListener('click', () => this.selectRandomTeam());

                // Add this to setupEventListeners method
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        e.target.closest('.difficulty-btn').classList.add('active');
                        const difficulty = e.target.closest('.difficulty-btn').dataset.difficulty;
                        this.battleSystem.setDifficulty(difficulty);
                    });
                });
                
                // Speed control listeners
                document.querySelectorAll('.speed-radio').forEach(radio => {
                    radio.addEventListener('click', (e) => {
                        const speed = parseInt(e.target.dataset.speed);
                        this.setSpeed(speed);
                    });
                });

                // Animation speed control listeners for battle (ADD THIS NEW CODE)
                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const speed = parseInt(e.target.dataset.speed);
                        this.battleSystem.setAnimationSpeed(speed);
                        
                        // Update UI
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                    });
                });

                // Battle log modal for mobile - REPLACE EXISTING SECTION
                const battleLogButton = document.getElementById('battleLogButton');
                const battleLogModal = document.getElementById('battleLogModal');
                const battleLogModalClose = document.getElementById('battleLogModalClose');

                if (battleLogButton) {
                    battleLogButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        battleLogModal.classList.add('show');
                        // Sync the modal content with current battle log
                        const currentLog = document.getElementById('battleLog').innerHTML;
                        const modalContent = document.getElementById('battleLogModalContent');
                        if (modalContent) {
                            modalContent.innerHTML = currentLog;
                            modalContent.scrollTop = modalContent.scrollHeight;
                        }
                    });
                }

                if (battleLogModalClose) {
                    battleLogModalClose.addEventListener('click', () => {
                        battleLogModal.classList.remove('show');
                    });
                }

                if (battleLogModal) {
                    battleLogModal.addEventListener('click', (e) => {
                        if (e.target === battleLogModal) {
                            battleLogModal.classList.remove('show');
                        }
                    });
                }
            }

            showResetConfirmation() {
                document.getElementById('confirmationPopup').classList.add('show');
            }

            confirmReset() {
                document.getElementById('confirmationPopup').classList.remove('show');
                this.resetGame();
            }

            cancelReset() {
                document.getElementById('confirmationPopup').classList.remove('show');
            }

            setSpeed(multiplier) {
                this.speedMultiplier = multiplier;
                
                // Update UI
                document.querySelectorAll('.speed-radio').forEach(radio => {
                    radio.classList.remove('active');
                });
                document.querySelector(`[data-speed="${multiplier}"]`).classList.add('active');
            }

            resetGame() {
                this.stopBotSolver();
                
                // Reset victory flag and hide message properly
                this.victoryShown = false;
                const victoryMessage = document.getElementById('victoryMessage');
                victoryMessage.classList.remove('show');
                
                this.characters = this.generateCharacters();
                this.selectedCharacters = [];
                this.selectedBattleTeam = [];
                this.botActive = false;
                this.speedMultiplier = 1;
                this.battleSystem = new BattleSystem(this);
                
                document.getElementById('botToggle').checked = false;
                document.getElementById('botStatus').textContent = 'Bot is off - You\'re in control';
                document.getElementById('botStatus').classList.remove('active');
                
                // Reset speed controls
                document.querySelectorAll('.speed-radio').forEach(radio => {
                    radio.classList.remove('active');
                });
                document.querySelector('[data-speed="1"]').classList.add('active');
                
                // Return to Fusion Tab
                document.querySelector('[data-tab="fusion"]').click();
                
                this.createTable();
                this.updateDisplay();
                this.updateBattleTeamSelection();
            }

            toggleBot(active) {
                this.botActive = active;
                const status = document.getElementById('botStatus');
                
                if (active) {
                    status.textContent = 'Bot is solving - Sit back and watch!';
                    status.classList.add('active');
                    this.startBotSolver();
                } else {
                    status.textContent = 'Bot is off - You\'re in control';
                    status.classList.remove('active');
                    this.stopBotSolver();
                }
            }

            startBotSolver() {
                if (this.botInterval) return;
                
                this.botInterval = setInterval(() => {
                    if (!this.botActive) return;
                    
                    const bestPair = this.findBestFusionPair();
                    if (bestPair) {
                        this.selectedCharacters = bestPair;
                        this.updateDisplay();
                        
                        setTimeout(() => {
                            if (this.botActive) {
                                this.fuse();
                            }
                        }, 1000);
                    }
                }, 4000);
            }

            stopBotSolver() {
                if (this.botInterval) {
                    clearInterval(this.botInterval);
                    this.botInterval = null;
                }
                this.selectedCharacters = [];
                this.updateDisplay();
            }

            findBestFusionPair() {
                const unlockedCharacters = Object.keys(this.characters).filter(id => this.characters[id].unlocked);
                const lockedCharacters = Object.keys(this.characters).filter(id => !this.characters[id].unlocked);
                
                if (lockedCharacters.length === 0) return null;
                
                let bestPair = null;
                let maxPotentialUnlocks = 0;
                
                for (let i = 0; i < unlockedCharacters.length; i++) {
                    for (let j = i; j < unlockedCharacters.length; j++) {
                        const char1 = this.characters[unlockedCharacters[i]];
                        const char2 = this.characters[unlockedCharacters[j]];
                        
                        const offspring = this.getPossibleOffspring(char1, char2);
                        const potentialUnlocks = offspring.filter(id => !this.characters[id].unlocked).length;
                        
                        if (potentialUnlocks > maxPotentialUnlocks) {
                            maxPotentialUnlocks = potentialUnlocks;
                            bestPair = [unlockedCharacters[i], unlockedCharacters[j]];
                        }
                    }
                }
                
                return bestPair;
            }
        }

        // Start the game
        new FusionGame();
    </script>
</body>
</html>
