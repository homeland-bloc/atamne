<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Atamne</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 10px;
            margin: 0;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 20px;
            max-width: 100%;
            width: 100%;
            min-height: auto;
            overflow-x: auto;
        }

        @media (min-width: 768px) {
            body {
                padding: 20px;
            }
            
            .game-container {
                padding: 40px;
                max-width: 1200px;
                min-height: 800px;
            }
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 1.8em;
            background: linear-gradient(45deg, #ef5350, #ff8a65, #ffeb3b, #66bb6a, #42a5f5, #ab47bc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            .game-title {
                font-size: 2.5em;
            }
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            gap: 5px;
            flex-wrap: wrap;
        }

        .tab-button {
            background: linear-gradient(45deg, #e0e0e0, #f5f5f5);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            color: #666;
            font-size: 16px;
        }

        .tab-button.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.3);
        }

        .tab-button:hover:not(.active) {
            background: linear-gradient(45deg, #d0d0d0, #e5e5e5);
            transform: translateY(-1px);
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef5350, #ff8a65, #ffeb3b, #66bb6a, #42a5f5, #ab47bc);
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .breeding-table {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            margin-bottom: 20px;
            max-width: 100%;
            width: 100%;
            justify-items: center;
        }

        @media (min-width: 768px) {
            .breeding-table {
                gap: 12px;
                margin-bottom: 30px;
                max-width: 600px;
                margin-left: auto;
                margin-right: auto;
            }
        }

        .character-slot {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            height: 50px;
            width: 50px;
            background: #f8f9fa;
            flex-shrink: 0;
        }

        @media (min-width: 768px) {
            .character-slot {
                height: 72px;
                width: 72px;
                border: 3px solid #ddd;
                border-radius: 15px;
            }
        }

        .character-slot.unlocked {
            border-color: #4ecdc4;
            background: white;
        }

        .character-slot.unlocked:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .character-slot.selected {
            border-color: #ff6b6b;
            background: #fff5f5;
            transform: scale(1.05);
        }

        .character-slot.locked {
            background: #f0f0f0;
            border-color: #ccc;
            cursor: not-allowed;
        }

        .character-sprite {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .character-sprite {
                font-size: 24px;
            }
        }

        /* Single gene styling - gradient from gene color to white */
        .single-gene {
            background: linear-gradient(135deg, var(--gene-color), white);
            font-size: 20px;
        }

        @media (min-width: 768px) {
            .single-gene {
                font-size: 32px;
            }
        }

        /* Double gene styling - side by side emojis */
        .double-gene {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 2px;
            font-size: 12px;
        }

        .double-gene.same-gene {
            background: var(--same-gene-gradient);
        }

        .double-gene.different-genes {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
        }

        @media (min-width: 768px) {
            .double-gene {
                gap: 4px;
                font-size: 18px;
            }
        }

        .double-gene .gene-emoji {
            display: inline-block;
            line-height: 1;
        }

        .locked-sprite {
            background: #ccc;
            color: #999;
            font-size: 18px;
        }

        @media (min-width: 768px) {
            .locked-sprite {
                font-size: 28px;
            }
        }

        .reset-section {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .reset-button, .breed-btn {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .breed-btn {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 50px;
        }

        .reset-button:hover, .breed-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.3);
        }

        .breed-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .breed-btn.breeding {
            animation: breedingPulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes breedingPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        .confirmation-popup {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .confirmation-popup.show {
            display: flex;
        }

        .confirmation-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px;
            margin: 20px;
        }

        .confirmation-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .confirm-btn, .cancel-btn {
            padding: 10px 25px;
            border: none;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .confirm-btn {
            background: #ff6b6b;
            color: white;
        }

        .confirm-btn:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }

        .cancel-btn {
            background: #e0e0e0;
            color: #666;
        }

        .cancel-btn:hover {
            background: #d0d0d0;
            transform: translateY(-2px);
        }

        .game-header-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            .game-header-controls {
                justify-content: center;
                gap: 30px;
            }
        }

        .progress-section {
            flex: 1;
            min-width: 200px;
            max-width: 400px;
        }

        .character-sprite::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3));
            z-index: -1;
        }

        .breeding-controls {
            text-align: center;
            margin-bottom: 20px;
        }

        .breeding-preview {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: none;
            overflow: hidden;
        }

        .breeding-preview.show {
            display: block;
            animation: breedingPreviewPop 0.3s ease-out;
        }

        @keyframes breedingPreviewPop {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .preview-character {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin: 0 auto;
            transition: all 0.2s ease;
            position: relative;
        }

        @media (min-width: 768px) {
            .preview-character {
                width: 100px;
                height: 100px;
                font-size: 36px;
            }
        }

        .preview-character.single-gene {
            background: linear-gradient(135deg, var(--gene-color), white);
        }

        .preview-character.double-gene {
            display: flex;
            flex-direction: row;
            gap: 4px;
            font-size: 20px;
        }

        .preview-character.double-gene.same-gene {
            background: var(--same-gene-gradient);
        }

        .preview-character.double-gene.different-genes {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
        }

        @media (min-width: 768px) {
            .preview-character.double-gene {
                gap: 6px;
                font-size: 28px;
            }
        }

        .sunshine-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.8) 0%, rgba(255, 215, 0, 0.4) 30%, transparent 70%);
            border-radius: 50%;
            animation: sunshineGlow 1s ease-out;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes sunshineGlow {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        }

        .breeding-sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
        }

        .bot-control {
            text-align: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            border: 2px solid #e0e0e0;
        }

        @media (min-width: 768px) {
            .bot-control {
                margin-bottom: 20px;
                padding: 15px;
            }
        }

        .bot-switch {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-weight: bold;
            color: #666;
            font-size: 14px;
            flex-wrap: wrap;
        }

        @media (min-width: 768px) {
            .bot-switch {
                gap: 15px;
                font-size: 16px;
            }
        }

        .control-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #666;
        }

        .speed-options {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .speed-option {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #666;
        }

        .speed-radio {
            width: 18px;
            height: 18px;
            border: 2px solid #ccc;
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .speed-radio.active {
            border-color: #4ecdc4;
            background: #4ecdc4;
        }

        .speed-radio.active::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .bot-status {
            margin-top: 10px;
            font-size: 14px;
            color: #999;
        }

        .bot-status.active {
            color: #4ecdc4;
            font-weight: bold;
        }

        .selection-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }

        .selected-character {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
        }

        .game-stats {
            text-align: center;
            color: #666;
            font-size: 16px;
        }

        .victory-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            z-index: 1000;
            display: none;
        }

        .victory-message.show {
            display: block;
            animation: victoryPop 0.6s ease-out;
        }

        @keyframes victoryPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .gene-labels {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            margin-bottom: 8px;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            justify-items: center;
        }

        @media (min-width: 768px) {
            .gene-labels {
                gap: 12px;
                margin-bottom: 10px;
                font-size: 12px;
                max-width: 600px;
                margin-left: auto;
                margin-right: auto;
            }
        }

        .gene-label {
            padding: 3px;
            border-radius: 8px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 25px;
            width: 50px;
        }

        @media (min-width: 768px) {
            .gene-label {
                padding: 5px;
                height: 30px;
                width: 72px;
            }
        }

        @keyframes newDiscovery {
            0% { transform: scale(0) rotate(0deg); }
            50% { transform: scale(1.2) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }

        .new-discovery {
            animation: newDiscovery 0.8s ease-out;
        }

        /* BATTLE ARENA STYLES */
        .battle-arena {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-height: 600px;
        }

        .turn-order-bar {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 2px solid #e0e0e0;
        }

        .turn-order-title {
            text-align: center;
            font-weight: bold;
            color: #666;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .turn-order-list {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .turn-indicator {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            background: white;
            transition: all 0.3s ease;
            position: relative;
        }

        .turn-indicator.active {
            border-color: #4ecdc4;
            background: #4ecdc4;
            color: white;
            transform: scale(1.2);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .turn-indicator.player {
            border-color: #42a5f5;
        }

        .turn-indicator.enemy {
            border-color: #ff6b6b;
        }

        .battle-field {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            min-height: 400px;
        }

        @media (max-width: 768px) {
            .battle-field {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .team-section {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .team-section.player-team {
            border-color: #42a5f5;
        }

        .team-section.enemy-team {
            border-color: #ff6b6b;
        }

        .team-title {
            text-align: center;
            font-weight: bold;
            color: #666;
            font-size: 18px;
            margin-bottom: 10px;
        }

        .team-title.player {
            color: #42a5f5;
        }

        .team-title.enemy {
            color: #ff6b6b;
        }

        .character-selection-panel {
            background: rgba(240, 240, 240, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #ddd;
            max-height: 200px;
            overflow-y: auto;
        }

        .random-select-btn {
            background: linear-gradient(45deg, #9c27b0, #673ab7);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            width: 100%;
        }

        .random-select-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.3);
        }

        .selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 10px;
            justify-items: center;
        }

        @media (min-width: 768px) {
            .selection-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            }
        }

        .selection-slot {
            width: 60px;
            height: 60px;
            border: 2px solid #ddd;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (min-width: 768px) {
            .selection-slot {
                width: 80px;
                height: 80px;
            }
        }

        .selection-slot:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        .selection-slot.selected {
            border-color: #4ecdc4;
            background: #f0ffff;
        }

        .battle-team-display {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .battle-character {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 10px;
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .battle-character.active {
            background: rgba(78, 205, 196, 0.1);
            border: 2px solid #4ecdc4;
        }

        .battle-character.defeated {
            opacity: 0.5;
            filter: grayscale(100%);
        }

        .battle-sprite {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            border: 2px solid #ddd;
            background: white;
        }

        @media (min-width: 768px) {
            .battle-sprite {
                width: 80px;
                height: 80px;
                font-size: 28px;
            }
        }

        .character-stats {
            text-align: center;
            font-size: 12px;
            color: #666;
        }

        .health-bar {
            width: 60px;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }

        @media (min-width: 768px) {
            .health-bar {
                width: 80px;
                height: 8px;
            }
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ffeb3b, #66bb6a);
            transition: width 0.5s ease;
            border-radius: 3px;
        }

        .battle-controls {
            position: sticky;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            text-align: center;
        }

        .attack-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .attack-btn {
            background: linear-gradient(45deg, var(--attack-color, #4ecdc4), var(--attack-color-light, #44a08d));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            min-width: 100px;
            position: relative;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .attack-btn {
                padding: 15px 30px;
                font-size: 16px;
                min-width: 120px;
            }
        }

        .attack-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .attack-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .attack-btn .effectiveness {
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
        }

        .attack-btn .effectiveness.super-effective {
            background: #66bb6a;
            color: white;
        }

        .attack-btn .effectiveness.not-very-effective {
            background: #ff6b6b;
            color: white;
        }

        .battle-log {
            background: rgba(240, 240, 240, 0.8);
            border-radius: 10px;
            padding: 15px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 14px;
            color: #666;
            border: 1px solid #ddd;
            margin-top: 15px;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid #eee;
        }

        .log-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .log-entry.damage {
            color: #ff6b6b;
        }

        .log-entry.super-effective {
            color: #66bb6a;
            font-weight: bold;
        }

        .log-entry.not-very-effective {
            color: #ff8a65;
        }

        .damage-number {
            position: absolute;
            font-size: 28px;
            font-weight: 900;
            color: #ff6b6b;
            z-index: 100;
            pointer-events: none;
            text-shadow: 
                2px 2px 0px #000,
                -2px -2px 0px #000,
                2px -2px 0px #000,
                -2px 2px 0px #000,
                0px 2px 4px rgba(0, 0, 0, 0.8);
            font-family: 'Arial Black', Arial, sans-serif;
            letter-spacing: 1px;
        }

        .damage-number.super-effective {
            color: #66bb6a;
            font-size: 36px;
            text-shadow: 
                2px 2px 0px #2e7d32,
                -2px -2px 0px #2e7d32,
                2px -2px 0px #2e7d32,
                -2px 2px 0px #2e7d32,
                0px 3px 6px rgba(46, 125, 50, 0.8);
        }

        .damage-number.not-very-effective {
            color: #ff8a65;
            font-size: 20px;
            text-shadow: 
                1px 1px 0px #e65100,
                -1px -1px 0px #e65100,
                1px -1px 0px #e65100,
                -1px 1px 0px #e65100,
                0px 2px 4px rgba(230, 81, 0, 0.6);
        }

        .damage-number.extremely-effective {
            color: #4caf50;
            font-size: 40px;
            text-shadow: 
                2px 2px 0px #2e7d32,
                -2px -2px 0px #2e7d32,
                2px -2px 0px #2e7d32,
                -2px 2px 0px #2e7d32,
                0px 3px 6px rgba(46, 125, 50, 0.8);
        }

        .damage-number.extremely-weak {
            color: #9e9e9e;
            font-size: 16px;
            text-shadow: 
                1px 1px 0px #424242,
                -1px -1px 0px #424242,
                1px -1px 0px #424242,
                -1px 1px 0px #424242,
                0px 2px 4px rgba(66, 66, 66, 0.6);
        }

        @keyframes damageFloat {
            0% {
                transform: translateY(0) scale(0.8);
                opacity: 0;
            }
            15% {
                transform: translateY(-10px) scale(1.1);
                opacity: 1;
            }
            85% {
                transform: translateY(-80px) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-120px) scale(0.9);
                opacity: 0;
            }
        }

        .damage-animation {
            animation: damageFloat 2.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        @keyframes battleShake {
            0%, 100% { 
                transform: translateX(0); 
            }
            10% { 
                transform: translateX(calc(-8px * var(--shake-intensity, 1))); 
            }
            20% { 
                transform: translateX(calc(8px * var(--shake-intensity, 1))); 
            }
            30% { 
                transform: translateX(calc(-6px * var(--shake-intensity, 1))); 
            }
            40% { 
                transform: translateX(calc(6px * var(--shake-intensity, 1))); 
            }
            50% { 
                transform: translateX(calc(-4px * var(--shake-intensity, 1))); 
            }
            60% { 
                transform: translateX(calc(4px * var(--shake-intensity, 1))); 
            }
            70% { 
                transform: translateX(calc(-2px * var(--shake-intensity, 1))); 
            }
            80% { 
                transform: translateX(calc(2px * var(--shake-intensity, 1))); 
            }
        }

        .battle-shake {
            animation: battleShake 0.5s ease-in-out;
        }

        .team-setup {
            text-align: center;
            padding: 20px;
        }

        .setup-instructions {
            margin-bottom: 20px;
            font-size: 16px;
            color: #666;
        }

        .start-battle-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .start-battle-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .start-battle-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .selected-team-display {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            border: 2px solid #e0e0e0;
        }

        .selected-team-title {
            font-weight: bold;
            color: #666;
            margin-bottom: 15px;
            text-align: center;
        }

        .selected-team-grid {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            /* Add safe area for device navigation */
            body {
                padding-bottom: env(safe-area-inset-bottom, 20px) !important;
            }
            
            /* Slightly smaller header to save some space */
            .game-title {
                font-size: 1.4em !important;
                margin-bottom: 10px !important;
            }
            
            .tab-navigation {
                margin-bottom: 15px !important;
            }
            
            /* Compact turn order */
            .turn-order-bar {
                padding: 8px !important;
                margin-bottom: 8px;
            }
            
            .turn-order-title {
                font-size: 12px !important;
                margin-bottom: 5px !important;
            }
            
            .turn-order-list {
                gap: 4px !important;
            }
            
            .turn-indicator {
                width: 32px !important;
                height: 32px !important;
                font-size: 10px !important;
            }
            
            /* Single column battle field */
            .battle-field {
                grid-template-columns: 1fr !important;
                gap: 10px !important;
            }
            
            /* Remove excessive padding/margins from team sections */
            .team-section {
                padding: 12px !important;
                min-height: auto !important;
                margin-bottom: 0 !important;
            }
            
            .team-title {
                font-size: 16px !important;
                margin-bottom: 10px !important;
            }
            
            /* Larger, more readable characters */
            .battle-character {
                padding: 8px !important;
                gap: 5px !important;
                min-width: 110px;
                max-width: 120px;
            }
            
            .battle-sprite {
                width: 50px !important;
                height: 50px !important;
                font-size: 18px !important;
            }
            
            .character-stats {
                font-size: 12px !important;
                line-height: 1.2 !important;
            }
            
            .character-stats div {
                margin-bottom: 2px !important;
            }
            
            .health-bar {
                width: 50px !important;
                height: 5px !important;
                margin-top: 4px !important;
            }
            
            .battle-team-display {
                gap: 10px !important;
                justify-content: space-around;
                flex-wrap: nowrap;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            /* REMOVE WASTED SPACE - tight battle arena */
            .battle-arena {
                padding-bottom: 140px !important; /* Increased space for controls */
                gap: 5px !important;
                padding-top: 0 !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: flex-start !important;
                min-height: calc(100vh - 200px) !important;
            }
            
            /* Remove extra space around team sections */
            .team-section.player-team {
                margin-bottom: 5px !important;
            }
            
            .team-section.enemy-team {
                margin-bottom: 5px !important;
                flex-grow: 0 !important; /* Don't let it expand */
            }
            
            /* IMPROVED battle controls positioning and sizing */
            .battle-controls {
                padding: 15px !important;
                position: fixed !important;
                bottom: max(30px, env(safe-area-inset-bottom, 30px)) !important; /* Support safe area */
                left: 10px !important;
                right: 10px !important;
                background: rgba(255, 255, 255, 0.98) !important;
                border-radius: 20px !important;
                max-height: 200px !important; /* Increased height */
                overflow-y: auto !important;
                z-index: 1000 !important;
                box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
                margin-bottom: max(30px, env(safe-area-inset-bottom, 30px)) !important; /* Support safe area */
            }
            
            /* Larger controls header */
            .battle-controls > div:first-child {
                margin-bottom: 12px !important;
                font-size: 16px !important;
                font-weight: bold !important;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            /* Larger quit button */
            #quitBattleBtn {
                padding: 8px 12px !important;
                font-size: 12px !important;
                min-width: auto !important;
                border-radius: 12px !important;
            }
            
            /* "Select an attack:" text */
            .attack-buttons > div:first-child {
                font-size: 15px !important;
                margin-bottom: 10px !important;
                font-weight: 500 !important;
            }
            
            /* IMPROVED attack buttons layout */
            .attack-buttons {
                flex-direction: row !important;
                gap: 8px !important; /* Reduced gap for better fit */
                justify-content: center;
                flex-wrap: wrap;
                margin-bottom: 0;
            }
            
            .attack-btn {
                min-width: 130px !important; /* Smaller for better fit */
                max-width: 150px !important; /* Prevent buttons from getting too wide */
                padding: 12px 16px !important; /* Smaller padding */
                font-size: 14px !important; /* Smaller font */
                font-weight: bold !important;
                border-radius: 16px !important;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                flex: 1 1 auto !important; /* Allow flexible sizing */
            }
            
            /* Hide battle log on mobile */
            .battle-log {
                display: none !important;
            }
            
            /* Container adjustments */
            .game-container {
                padding: 8px !important;
                padding-bottom: 100px !important; /* Increased safe area at bottom */
                min-height: 100vh;
                display: flex;
                flex-direction: column;
            }
            
            /* Make turn order more compact on mobile */
            .turn-order-bar {
                padding: 10px !important;
                margin-bottom: 5px !important;
            }
            
            .turn-order-title {
                font-size: 12px !important;
                margin-bottom: 8px !important;
            }
            
            .turn-indicator {
                width: 35px !important;
                height: 35px !important;
                font-size: 11px !important;
            }
            
            /* Remove any flex-grow that might cause spacing issues */
            .tab-content {
                flex-grow: 0 !important;
            }
            
            /* Ensure battle arena has proper spacing */
            .battle-arena {
                padding-bottom: 120px !important; /* Space for controls */
            }
            
            /* Improve button touch targets */
            .attack-btn {
                min-height: 44px !important; /* iOS minimum touch target */
            }
            
            /* Better spacing for attack selection text */
            .attack-buttons > div:first-child {
                margin-bottom: 12px !important;
                padding: 0 10px !important;
            }
            
            .log-entry.player-attack {
                color: #2e7d32;
                font-weight: bold;
            }

            .log-entry.enemy-attack {
                color: #c62828;
                font-weight: bold;
            }

            .log-entry.player-attack.super-effective {
                color: #1b5e20;
                background: rgba(76, 175, 80, 0.1);
                border-left: 3px solid #4caf50;
                padding-left: 8px;
            }

            .log-entry.enemy-attack.super-effective {
                color: #b71c1c;
                background: rgba(244, 67, 54, 0.1);
                border-left: 3px solid #f44336;
                padding-left: 8px;
            }

            .log-entry.player-attack.not-very-effective {
                color: #388e3c;
                opacity: 0.8;
            }

            .log-entry.enemy-attack.not-very-effective {
                color: #d32f2f;
                opacity: 0.8;
            }
            
            /* FIXED target selection button layout - ensure all 3 buttons fit */
            .attack-buttons .attack-btn[style*="background"] {
                min-width: 100px !important; /* Smaller for target buttons */
                max-width: 120px !important;
                padding: 10px 12px !important;
                font-size: 12px !important;
                margin: 2px !important;
                flex: 1 1 100px !important; /* Fixed basis for consistent sizing */
                white-space: nowrap !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
            }
            
            /* Ensure target container fits properly with all 3 buttons */
            .attack-buttons > div:last-child {
                display: flex !important;
                gap: 6px !important; /* Reduced gap */
                justify-content: center !important;
                flex-wrap: wrap !important;
                width: 100% !important;
                max-width: 100% !important;
                padding: 0 5px !important; /* Add small padding for edge spacing */
            }
            
            /* Additional responsive adjustments for very small screens */
            @media (max-width: 360px) {
                .attack-buttons .attack-btn[style*="background"] {
                    min-width: 90px !important;
                    max-width: 110px !important;
                    padding: 8px 10px !important;
                    font-size: 11px !important;
                    flex: 1 1 90px !important;
                }
                
                .attack-buttons > div:last-child {
                    gap: 4px !important;
                }
            }
            
            /* Mobile-optimized damage numbers with effectiveness indicators */
            .damage-number {
                font-size: 24px !important;
                max-width: 200px !important;
                text-align: center !important;
                word-wrap: break-word !important;
                line-height: 1.2 !important;
                padding: 2px 4px !important;
                border-radius: 8px !important;
                background: rgba(0, 0, 0, 0.7) !important;
                backdrop-filter: blur(4px) !important;
            }
            
            .damage-number.super-effective {
                font-size: 28px !important;
                background: rgba(46, 125, 50, 0.8) !important;
            }
            
            .damage-number.not-very-effective {
                font-size: 20px !important;
                background: rgba(230, 81, 0, 0.8) !important;
            }
            
            .damage-number.extremely-effective {
                font-size: 32px !important;
                background: rgba(46, 125, 50, 0.9) !important;
            }
            
            .damage-number.extremely-weak {
                font-size: 18px !important;
                background: rgba(66, 66, 66, 0.8) !important;
            }
        }

        .difficulty-btn {
            padding: 10px 20px;
            border: 2px solid #ddd;
            background: white;
            color: #666;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .difficulty-btn:hover:not(.active) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-color: #999;
        }

        .difficulty-btn.active {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            border-width: 3px;
        }

        /* Inactive state - all buttons have subtle gradient */
        .difficulty-btn[data-difficulty="easy"] {
            background: #f9f9f9;
            border-color: #e0e0e0;
        }

        .difficulty-btn[data-difficulty="normal"] {
            background: #f5f5f5;
            border-color: #d0d0d0;
        }

        .difficulty-btn[data-difficulty="hard"] {
            background: #eeeeee;
            border-color: #bdbdbd;
        }

        .difficulty-btn[data-difficulty="extreme"] {
            background: #e0e0e0;
            border-color: #9e9e9e;
        }

        /* Active state - strong visual indicator */
        .difficulty-btn[data-difficulty="easy"].active {
            background: linear-gradient(135deg, #ffffff, #f0f0f0);
            border-color: #4caf50;
            color: #2e7d32;
            position: relative;
        }

        .difficulty-btn[data-difficulty="normal"].active {
            background: linear-gradient(135deg, #e8e8e8, #d0d0d0);
            border-color: #ff9800;
            color: #424242;
        }

        .difficulty-btn[data-difficulty="hard"].active {
            background: linear-gradient(135deg, #9e9e9e, #757575);
            border-color: #ff5722;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .difficulty-btn[data-difficulty="extreme"].active {
            background: linear-gradient(135deg, #424242, #212121);
            border-color: #d32f2f;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* Add a glow effect for active buttons */
        .difficulty-btn.active::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: inherit;
            border-radius: 20px;
            opacity: 0.3;
            z-index: -1;
            filter: blur(8px);
        }

        /* Make the small text more visible */
        .difficulty-btn small {
            display: block;
            font-size: 10px;
            opacity: 0.8;
            margin-top: 2px;
        }

        .difficulty-btn.active small {
            opacity: 1;
            font-weight: normal;
        }

        @keyframes slideLeft {
            0% { transform: translateX(50px); opacity: 0.7; }
            100% { transform: translateX(0); opacity: 1; }
        }

        .turn-order-list {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            transition: all 0.3s ease;
        }

        .turn-indicator {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            background: white;
            transition: all 0.3s ease;
            position: relative;
        }

        .turn-indicator.active {
            border-color: #4ecdc4;
            background: #4ecdc4;
            color: white;
            transform: scale(1.2);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1.2); }
            50% { transform: scale(1.3); }
        }

        .battle-sprite.single-gene {
            background: linear-gradient(135deg, var(--gene-color), white) !important;
        }

        /* Special Abilities and Status Effects Styling */
        .ability-icon {
            animation: abilityPulse 2s ease-in-out infinite;
        }

        @keyframes abilityPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .status-effects {
            min-height: 16px;
        }

        .status-effects span {
            animation: statusGlow 1.5s ease-in-out infinite alternate;
        }

        @keyframes statusGlow {
            0% { filter: brightness(1); }
            100% { filter: brightness(1.3) drop-shadow(0 0 3px rgba(255, 255, 255, 0.5)); }
        }

        /* Invisibility effect */
        .battle-character.invisible .battle-sprite {
            opacity: 0.6;
            filter: blur(1px);
        }

        /* Rage effect */
        .battle-character.rage .battle-sprite {
            animation: rageShake 0.5s ease-in-out infinite;
        }

        @keyframes rageShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        /* Curse effect */
        .battle-character.cursed .battle-sprite {
            filter: hue-rotate(280deg) brightness(0.8);
        }

        /* Speed debuff effect */
        .battle-character.speed-debuff .battle-sprite {
            filter: brightness(0.7) saturate(0.5);
        }

        /* Momentum effect */
        .battle-character.momentum .battle-sprite {
            animation: momentumGlow 2s ease-in-out infinite;
        }

        @keyframes momentumGlow {
            0%, 100% { 
                filter: brightness(1) drop-shadow(0 0 5px #42a5f5);
            }
            50% { 
                filter: brightness(1.2) drop-shadow(0 0 15px #42a5f5);
            }
        }

        /* Orange armor effect */
        .battle-character.armor .battle-sprite {
            filter: drop-shadow(0 0 8px #ff8a65);
        }

        /* Green thorn effect */
        .battle-character.thorn .battle-sprite {
            filter: drop-shadow(0 0 6px #66bb6a);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">Gene Breeding & Battle Simulator</h1>
            
            <div class="tab-navigation">
                <button class="tab-button active" data-tab="breeding"> Breeding Lab</button>
                <button class="tab-button" data-tab="battle"> Battle Arena</button>
            </div>
        </div>

        <!-- BREEDING TAB -->
        <div class="tab-content active" id="breeding-tab">
            <div class="game-header-controls">
                <div class="progress-section">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="game-stats">
                        <span id="unlockedCount">6</span> / 42 creatures discovered
                    </div>
                </div>
            </div>

            <div class="gene-labels">
                <div class="gene-label" style="background: #ef5350;">Red</div>
                <div class="gene-label" style="background: #ff8a65;">Orange</div>
                <div class="gene-label" style="background: #ffeb3b;">Yellow</div>
                <div class="gene-label" style="background: #66bb6a;">Green</div>
                <div class="gene-label" style="background: #42a5f5;">Blue</div>
                <div class="gene-label" style="background: #ab47bc;">Purple</div>
                <div class="gene-label" style="background: #666;">Singles</div>
            </div>

            <div class="breeding-table" id="breedingTable"></div>

            <div class="bot-control">
                <div class="control-row">
                    <div class="bot-switch">
                        <span>Manual</span>
                        <label class="switch">
                            <input type="checkbox" id="botToggle">
                            <span class="slider"></span>
                        </label>
                        <span>Bot Solver</span>
                    </div>
                    <div class="speed-control">
                        <div class="speed-options">
                            <div class="speed-option">
                                <div class="speed-radio active" data-speed="1"></div>
                                <span>1x</span>
                            </div>
                            <div class="speed-option">
                                <div class="speed-radio" data-speed="2"></div>
                                <span>2x</span>
                            </div>
                            <div class="speed-option">
                                <div class="speed-radio" data-speed="4"></div>
                                <span>4x</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="bot-status" id="botStatus">Bot is off - You're in control</div>
            </div>

            <div class="selection-display">
                <div class="selected-character">
                    <div>Parent 1</div>
                    <div class="character-slot" id="parent1Display">
                        <div class="character-sprite locked-sprite">?</div>
                    </div>
                </div>
                <div style="font-size: 24px; color: #666;">+</div>
                <div class="selected-character">
                    <div>Parent 2</div>
                    <div class="character-slot" id="parent2Display">
                        <div class="character-sprite locked-sprite">?</div>
                    </div>
                </div>
            </div>

            <div class="breeding-controls">
                <button class="breed-btn" id="breedBtn" disabled>Select Two Creatures to Breed</button>
            </div>

            <div class="reset-section">
                <button class="reset-button" id="resetButton"> Reset Game</button>
                <button class="reset-button" id="unlockAllBtn" style="background: linear-gradient(45deg, #4ecdc4, #44a08d); margin-right: 15px;"> Unlock All Characters</button>
            </div>
        </div>

        <!-- BATTLE TAB -->
        <div class="tab-content" id="battle-tab">
            <div id="team-setup" class="team-setup">
                <div class="setup-instructions">
                    <h3 style="color: #666; margin-bottom: 15px;">Choose Your Battle Team</h3>
                    <p>Select 3 creatures from your unlocked collection to form your battle team!</p>
                </div>

                <div class="character-selection-panel">
                    <button class="random-select-btn" id="randomSelectBtn"> Select 3 Random Characters</button>
                    <div class="selection-grid" id="battleCharacterSelection"></div>
                </div>

                <div class="selected-team-display">
                    <div class="selected-team-title">Your Team (Select 3)</div>
                    <div class="selected-team-grid" id="selectedTeamDisplay"></div>
                </div>

                <div class="difficulty-selection" style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.8); border-radius: 15px; border: 2px solid #e0e0e0;">
                <div style="font-weight: bold; color: #666; margin-bottom: 15px; text-align: center;">Enemy AI Difficulty</div>
                <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                    <button class="difficulty-btn active" data-difficulty="easy">
                         Easy<small>Random moves</small>
                    </button>
                    <button class="difficulty-btn" data-difficulty="normal">
                         Normal<small>Semi-smart</small>
                    </button>
                    <button class="difficulty-btn" data-difficulty="hard">
                         Hard<small>Strategic</small>
                    </button>
                    <button class="difficulty-btn" data-difficulty="extreme">
                         Extreme<small>Perfect play</small>
                    </button>
                </div>
            </div>

                <button class="start-battle-btn" id="startBattleBtn" disabled>Select 3 Creatures to Start Battle</button>
            </div>

            <div id="battle-arena" class="battle-arena" style="display: none;">
                <div class="turn-order-bar">
                    <div class="turn-order-title">Turn Order</div>
                    <div class="turn-order-list" id="turnOrderList"></div>
                </div>

                <div class="battle-field">
                    <div class="team-section player-team">
                        <div class="team-title player">Your Team</div>
                        <div class="battle-team-display" id="playerTeamDisplay"></div>
                    </div>

                    <div class="team-section enemy-team">
                        <div class="team-title enemy">Enemy Team</div>
                        <div class="battle-team-display" id="enemyTeamDisplay"></div>
                    </div>
                </div>

                <div class="battle-controls" id="battleControls">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div style="font-weight: bold; color: #666;">
                            <span id="activeCharacterName">Character</span>'s Turn
                        </div>
                        <button class="cancel-btn" id="quitBattleBtn" style="padding: 5px 15px; font-size: 12px;">Quit</button>
                    </div>
                    <div class="attack-buttons" id="attackButtons"></div>
                    <div class="battle-log" id="battleLog"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Popups and Effects -->
    <div class="confirmation-popup" id="confirmationPopup">
        <div class="confirmation-content">
            <h3 style="color: #666; margin-bottom: 15px;">Reset Game?</h3>
            <p style="color: #888; margin-bottom: 20px;">This will clear all your progress and discoveries. Are you sure?</p>
            <div class="confirmation-buttons">
                <button class="confirm-btn" id="confirmReset">Yes, Reset</button>
                <button class="cancel-btn" id="cancelReset">Cancel</button>
            </div>
        </div>
    </div>

    <div class="breeding-preview" id="breedingPreview">
        <h3 style="text-align: center; margin-bottom: 20px; color: #666;">Breeding...</h3>
        <div class="preview-character" id="previewCharacter">?</div>
    </div>

    <div class="victory-message" id="victoryMessage">
        <h2 style="color: #4ecdc4; margin-bottom: 20px;"> Congratulations! </h2>
        <p style="font-size: 18px; color: #666;">You've discovered all 42 gene combinations!</p>
        <p style="margin-top: 10px; color: #999;">Master breeder achievement unlocked!</p>
    </div>

    <script>
        const GENES = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Purple'];
        const GENE_COLORS = {
            'Red': '#ef5350',
            'Orange': '#ff8a65', 
            'Yellow': '#ffeb3b',
            'Green': '#66bb6a',
            'Blue': '#42a5f5',
            'Purple': '#ab47bc'
        };

        // Lighter versions for same-gene gradients
        const GENE_LIGHT_COLORS = {
            'Red': '#ffcdd2',
            'Orange': '#ffccbc', 
            'Yellow': '#fff9c4',
            'Green': '#c8e6c9',
            'Blue': '#bbdefb',
            'Purple': '#e1bee7'
        };

        // Darker versions for same-gene gradients
        const GENE_DARK_COLORS = {
            'Red': '#c62828',
            'Orange': '#e65100', 
            'Yellow': '#f57f17',
            'Green': '#2e7d32',
            'Blue': '#1565c0',
            'Purple': '#6a1b9a'
        };

        const GENE_SYMBOLS = {
            'Red': '',
            'Orange': '',
            'Yellow': '',
            'Green': '',
            'Blue': '',
            'Purple': ''
        };

        // Special Abilities System
        const SPECIAL_ABILITIES = {
            'Red': {
                name: 'Blood Rage',
                description: 'Become invisible and gain +25% damage effectiveness when HP drops below 75%',
                trigger: 'passive',
                effect: 'blood_rage'
            },
            'Orange': {
                name: 'Molten Armor',
                description: 'Reduce all incoming damage by 16 points (minimum 1 damage taken)',
                trigger: 'passive',
                effect: 'damage_reduction'
            },
            'Yellow': {
                name: 'Solar Recovery',
                description: 'Heal HP equal to attack damage at start of each turn',
                trigger: 'turn_start',
                effect: 'healing'
            },
            'Green': {
                name: 'Thorn Skin',
                description: 'Reflect 50% of incoming damage back to attacker',
                trigger: 'passive',
                effect: 'reflection'
            },
            'Blue': {
                name: 'Momentum',
                description: 'Gain +8 speed permanently at start of each turn AND when attacked',
                trigger: 'passive',
                effect: 'momentum'
            },
            'Purple': {
                name: 'Hex Mark',
                description: 'Attacks reduce target\'s damage effectiveness by 25% for their next turn',
                trigger: 'on_attack',
                effect: 'curse'
            }
        };

        // Type effectiveness system: RedOrangeYellowGreenBluePurpleRed
        const TYPE_EFFECTIVENESS = {
            'Red': { 'Orange': 1.5, 'Yellow': 1.25, 'Purple': 0.5, 'Blue': 0.75 },
            'Orange': { 'Yellow': 1.5, 'Green': 1.25, 'Red': 0.5, 'Purple': 0.75 },
            'Yellow': { 'Green': 1.5, 'Blue': 1.25, 'Orange': 0.5, 'Red': 0.75 },
            'Green': { 'Blue': 1.5, 'Purple': 1.25, 'Yellow': 0.5, 'Orange': 0.75 },
            'Blue': { 'Purple': 1.5, 'Red': 1.25, 'Green': 0.5, 'Yellow': 0.75 },
            'Purple': { 'Red': 1.5, 'Orange': 1.25, 'Blue': 0.5, 'Green': 0.75 }
        };

        class GameCharacter {
            constructor(id, genes, unlocked = false) {
                this.id = id;
                this.genes = genes;
                this.unlocked = unlocked;
                this.symbol = this.generateSymbol();
                this.stats = this.generateStats();
                
                // Special ability assignment based on secondary gene (or primary for single-gene characters)
                this.specialAbility = this.assignSpecialAbility();
                
                // Status effect tracking
                this.statusEffects = {
                    invisibility: { active: false, duration: 0 },
                    speedDebuff: { active: false, duration: 0, amount: 0 },
                    curse: { active: false, duration: 0 },
                    bloodRage: { active: false, damageBonus: 0 },
                    momentum: { speedStacks: 0 },
                    damageReduction: { active: false }
                };
            }

            generateSymbol() {
                if (this.genes.length === 1) {
                    return GENE_SYMBOLS[this.genes[0]];
                } else {
                    return `${GENE_SYMBOLS[this.genes[0]]}${GENE_SYMBOLS[this.genes[1]]}`;
                }
            }

            getStatDistribution() {
                // Define base stats for all 42 characters (HP tripled for gameplay)
                // Budget formula: (HP3) + Attack + Speed = 200 for all characters
                // 40 minimum rule applied: no stat below 40
                const statMap = {
                    // Single genes (HP tripled, but (HP3) + ATK + SPD = 200)
                    'Red': [120, 120, 40],        // (1203) + 120 + 40 = 200
                    'Orange': [240, 80, 40],      // (2403) + 80 + 40 = 200  
                    'Yellow': [360, 40, 40],      // (3603) + 40 + 40 = 200
                    'Green': [240, 40, 80],       // (2403) + 40 + 80 = 200
                    'Blue': [120, 40, 120],       // (1203) + 40 + 120 = 200
                    'Purple': [120, 80, 80],      // (1203) + 80 + 80 = 200
                    
                    // Same-gene doubles (HP tripled, but (HP3) + ATK + SPD = 200)
                    'Red-Red': [144, 104, 48],       // (1443) + 104 + 48 = 200
                    'Orange-Orange': [216, 72, 56], // (2163) + 72 + 56 = 200
                    'Yellow-Yellow': [312, 48, 48], // (3123) + 48 + 48 = 200
                    'Green-Green': [216, 56, 72],   // (2163) + 56 + 72 = 200
                    'Blue-Blue': [144, 48, 104],    // (1443) + 48 + 104 = 200
                    'Purple-Purple': [168, 72, 72], // (1683) + 72 + 72 = 200
                    
                    // Different-gene doubles (HP tripled, 40 minimum rule applied)
                    'Red-Orange': [216, 88, 40],    // (2163) + 88 + 40 = 200
                    'Red-Yellow': [300, 60, 40],    // (3003) + 60 + 40 = 200
                    'Red-Green': [216, 56, 72],     // (2163) + 56 + 72 = 200
                    'Red-Blue': [120, 60, 100],     // (1203) + 60 + 100 = 200
                    'Red-Purple': [120, 88, 72],    // (1203) + 88 + 72 = 200

                    'Orange-Red': [156, 108, 40],   // (1563) + 108 + 40 = 200
                    'Orange-Yellow': [324, 52, 40], // (3243) + 52 + 40 = 200
                    'Orange-Green': [240, 48, 72],  // (2403) + 48 + 72 = 200
                    'Orange-Blue': [156, 52, 96],   // (1563) + 52 + 96 = 200
                    'Orange-Purple': [144, 80, 72], // (1443) + 80 + 72 = 200

                    'Yellow-Red': [180, 100, 40],   // (1803) + 100 + 40 = 200
                    'Yellow-Orange': [264, 72, 40], // (2643) + 72 + 40 = 200
                    'Yellow-Green': [264, 40, 72],  // (2643) + 40 + 72 = 200
                    'Yellow-Blue': [180, 40, 100],  // (1803) + 40 + 100 = 200
                    'Yellow-Purple': [168, 72, 72], // (1683) + 72 + 72 = 200
                    
                    'Green-Red': [156, 96, 52],     // (1563) + 96 + 52 = 200
                    'Green-Orange': [240, 72, 48],  // (2403) + 72 + 48 = 200
                    'Green-Yellow': [324, 40, 52],  // (3243) + 40 + 52 = 200
                    'Green-Blue': [156, 40, 108],   // (1563) + 40 + 108 = 200
                    'Green-Purple': [144, 72, 80],  // (1443) + 72 + 80 = 200
                    
                    'Blue-Red': [120, 100, 60],     // (1203) + 100 + 60 = 200
                    'Blue-Orange': [216, 72, 56],   // (2163) + 72 + 56 = 200
                    'Blue-Yellow': [300, 40, 60],   // (3003) + 40 + 60 = 200
                    'Blue-Green': [216, 40, 88],    // (2163) + 40 + 88 = 200
                    'Blue-Purple': [120, 72, 88],   // (1203) + 72 + 88 = 200
                    
                    'Purple-Red': [120, 108, 52],   // (1203) + 108 + 52 = 200
                    'Purple-Orange': [216, 80, 48], // (2163) + 80 + 48 = 200
                    'Purple-Yellow': [288, 52, 52], // (2883) + 52 + 52 = 200
                    'Purple-Green': [216, 48, 80],  // (2163) + 48 + 80 = 200
                    'Purple-Blue': [120, 52, 108]   // (1203) + 52 + 108 = 200
                };
                
                return statMap[this.id] || [80, 80, 80]; // Fallback for any missing characters
            }

            generateStats() {
                const [hp, attack, speed] = this.getStatDistribution();
                
                return {
                    hp: hp,
                    maxHp: hp,
                    attack: attack,
                    speed: speed
                };
            }

            hashCode(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash;
            }

            getAttackGenes() {
                if (this.genes.length === 1) {
                    return [
                        { gene: this.genes[0], type: 'single' },
                        { gene: 'Neutral', type: 'single' }
                    ];
                } else if (this.genes[0] === this.genes[1]) {
                    // Same gene: first attack is single, second is splash
                    return [
                        { gene: this.genes[0], type: 'single' },
                        { gene: this.genes[0], type: 'splash' }
                    ];
                } else {
                    // Different genes: both are single target
                    return [
                        { gene: this.genes[0], type: 'single' },
                        { gene: this.genes[1], type: 'single' }
                    ];
                }
            }

            getEffectiveness(attackGene, defendingCharacter) {
                if (attackGene === 'Neutral') return 1.0;
                
                // Only use the FIRST gene for defense
                const defendingGene = defendingCharacter.genes[0];
                
                return TYPE_EFFECTIVENESS[attackGene]?.[defendingGene] || 1.0;
            }

            calculateDamage(attackGene, defendingCharacter) {
                const baseDamage = this.stats.attack;
                let effectiveness = this.getEffectiveness(attackGene, defendingCharacter);
                
                // Apply Blood Rage damage bonus if active
                if (this.statusEffects.bloodRage.active) {
                    effectiveness += 0.25; // +25% damage effectiveness
                }
                
                // Apply curse damage reduction if active
                if (this.statusEffects.curse.active) {
                    effectiveness *= 0.75; // -25% damage effectiveness
                }
                
                const finalDamage = baseDamage * effectiveness;
                
                // Since all stats are divisible by 4, and effectiveness modifiers are additive
                // The result will always be a whole number
                return Math.round(finalDamage);
            }

            assignSpecialAbility() {
                // For single-gene characters, use their primary gene
                // For double-gene characters, use the SECOND gene in their ID
                const abilityGene = this.genes.length === 1 ? this.genes[0] : this.genes[1];
                return SPECIAL_ABILITIES[abilityGene] || null;
            }

            getAbilityName() {
                return this.specialAbility ? this.specialAbility.name : 'None';
            }

            getAbilityDescription() {
                return this.specialAbility ? this.specialAbility.description : 'No special ability';
            }

            isInvisible() {
                return this.statusEffects.invisibility.active;
            }

            isCursed() {
                return this.statusEffects.curse.active;
            }

            getSpeedDebuff() {
                return this.statusEffects.speedDebuff.active ? this.statusEffects.speedDebuff.amount : 0;
            }

            getEffectiveSpeed() {
                // Base speed + momentum stacks - speed debuffs
                const momentumBonus = this.statusEffects.momentum.speedStacks * 8;
                const speedDebuff = this.getSpeedDebuff();
                return Math.max(1, this.stats.speed + momentumBonus - speedDebuff);
            }

            applyDamageReduction(damage) {
                if (this.specialAbility && this.specialAbility.effect === 'damage_reduction') {
                    return Math.max(1, damage - 16);
                }
                return damage;
            }

            triggerBloodRage() {
                if (this.specialAbility && this.specialAbility.effect === 'blood_rage' && 
                    this.hp <= this.stats.maxHp * 0.75 && !this.statusEffects.bloodRage.active) {
                    
                    this.statusEffects.bloodRage.active = true;
                    this.statusEffects.bloodRage.damageBonus = 0.25; // +25% damage effectiveness
                    this.statusEffects.invisibility.active = true;
                    this.statusEffects.invisibility.duration = 2;
                    
                    return true; // Indicates blood rage was triggered
                }
                return false;
            }

            triggerThornSkin(attacker, damage) {
                if (this.specialAbility && this.specialAbility.effect === 'reflection') {
                    const reflectedDamage = Math.floor(damage * 0.5);
                    return reflectedDamage;
                }
                return 0;
            }

            triggerMomentum() {
                if (this.specialAbility && this.specialAbility.effect === 'momentum') {
                    this.statusEffects.momentum.speedStacks++;
                    return true;
                }
                return false;
            }

            applyCurse(target) {
                if (this.specialAbility && this.specialAbility.effect === 'curse') {
                    target.statusEffects.curse.active = true;
                    target.statusEffects.curse.duration = 1;
                    return true;
                }
                return false;
            }

            healFromSolarRecovery() {
                if (this.specialAbility && this.specialAbility.effect === 'healing') {
                    // Heal amount equal to attack damage (including gene effectiveness bonuses)
                    const healAmount = this.stats.attack;
                    const oldHp = this.hp;
                    this.hp = Math.min(this.stats.maxHp, this.hp + healAmount);
                    return this.hp - oldHp; // Return actual amount healed
                }
                return 0;
            }

            updateStatusEffects() {
                // Update invisibility duration
                if (this.statusEffects.invisibility.active) {
                    this.statusEffects.invisibility.duration--;
                    if (this.statusEffects.invisibility.duration <= 0) {
                        this.statusEffects.invisibility.active = false;
                        this.statusEffects.invisibility.duration = 0;
                        // Clear blood rage when invisibility ends
                        if (this.statusEffects.bloodRage.active) {
                            this.statusEffects.bloodRage.active = false;
                            this.statusEffects.bloodRage.damageBonus = 0;
                        }
                    }
                }

                // Update speed debuff duration
                if (this.statusEffects.speedDebuff.active) {
                    this.statusEffects.speedDebuff.duration--;
                    if (this.statusEffects.speedDebuff.duration <= 0) {
                        this.statusEffects.speedDebuff.active = false;
                        this.statusEffects.speedDebuff.duration = 0;
                        this.statusEffects.speedDebuff.amount = 0;
                    }
                }

                // Update curse duration
                if (this.statusEffects.curse.active) {
                    this.statusEffects.curse.duration--;
                    if (this.statusEffects.curse.duration <= 0) {
                        this.statusEffects.curse.active = false;
                        this.statusEffects.curse.duration = 0;
                    }
                }
            }

            getDamageMultiplier() {
                // Apply curse effect (25% damage reduction)
                if (this.statusEffects.curse.active) {
                    return 0.75;
                }
                return 1.0;
            }
        }

        class BattleSystem {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.playerTeam = [];
                this.enemyTeam = [];
                this.turnQueue = [];
                this.currentTurnIndex = 0;
                this.battlePhase = 'setup'; // setup, battle, ended
                this.battleLog = [];
                this.difficulty = 'easy'; // Default difficulty
                this.actionBars = {}; // Track action bar fill for each character
                this.turnHistory = []; // Track completed turns
                this.upcomingTurns = []; // Pre-calculated upcoming turns
                this.ACTION_THRESHOLD = 1000; // Action bar threshold
                this.isProcessingTurn = false; // Flag to prevent multiple attacks in one turn
                this.attackButtonsDisabled = false; // Flag to disable attack buttons
            }

            setDifficulty(difficulty) {
                this.difficulty = difficulty;
            }

            clearAllTimers() {
                // Clear any pending AI turn timers
                if (this.aiTurnTimer) {
                    clearTimeout(this.aiTurnTimer);
                    this.aiTurnTimer = null;
                }
                
                // Clear any other pending timers that might be running
                if (this.nextTurnTimer) {
                    clearTimeout(this.nextTurnTimer);
                    this.nextTurnTimer = null;
                }
            }

            showQuitConfirmation() {
                const popup = document.createElement('div');
                popup.className = 'confirmation-popup show';
                popup.innerHTML = `
                    <div class="confirmation-content">
                        <h3 style="color: #666; margin-bottom: 15px;">Quit Battle?</h3>
                        <p style="color: #888; margin-bottom: 20px;">Are you sure you want to quit this battle? Your progress will be lost.</p>
                        <div class="confirmation-buttons">
                            <button class="confirm-btn" id="confirmQuit">Yes, Quit</button>
                            <button class="cancel-btn" id="cancelQuit">Cancel</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(popup);
                
                document.getElementById('confirmQuit').addEventListener('click', () => {
                    popup.remove();
                    this.returnToSetup();
                });
                
                document.getElementById('cancelQuit').addEventListener('click', () => {
                    popup.remove();
                });
            }

            setupBattle(playerTeam) {
                this.playerTeam = playerTeam.map(char => Object.assign(Object.create(Object.getPrototypeOf(char)), char));
                this.playerTeam.forEach(char => {
                    char.hp = char.stats.maxHp;
                    char.isPlayer = true;
                    // Initialize status effects for battle
                    char.statusEffects = {
                        invisibility: { active: false, duration: 0 },
                        speedDebuff: { active: false, duration: 0, amount: 0 },
                        curse: { active: false, duration: 0 },
                        bloodRage: { active: false, damageBonus: 0 },
                        momentum: { speedStacks: 0 },
                        damageReduction: { active: false }
                    };
                });

                this.generateEnemyTeam();
                this.createTurnQueue(); // This now uses the speed bar system
                
                this.battlePhase = 'battle';
                this.battleLog = [];
                this.previousFirstTurn = null;
                
                // Reset attack button states
                this.attackButtonsDisabled = false;
                this.isProcessingTurn = false;
                
                this.renderBattleArena();
                
                // Handle first turn
                const firstChar = this.getCurrentCharacter();
                if (firstChar && !firstChar.isPlayer) {
                    setTimeout(() => this.processAITurn(), 1500);
                }
            }

            generateEnemyTeam() {
                const availableCharacters = Object.values(this.game.characters)
                    .filter(char => char.unlocked && !this.playerTeam.some(pChar => pChar.id === char.id));
                
                // If not enough unique characters, allow duplicates but mark them differently
                if (availableCharacters.length < 3) {
                    const allAvailable = Object.values(this.game.characters).filter(char => char.unlocked);
                    this.enemyTeam = [];
                    for (let i = 0; i < 3; i++) {
                        const randomChar = allAvailable[Math.floor(Math.random() * allAvailable.length)];
                        const enemyChar = Object.assign(Object.create(Object.getPrototypeOf(randomChar)), randomChar);
            
                        // Add unique suffix if character already exists in player team
                        if (this.playerTeam.some(pChar => pChar.id === enemyChar.id)) {
                            enemyChar.id = `${enemyChar.id}-E${i + 1}`;
                        }
                        
                        enemyChar.hp = enemyChar.stats.maxHp;
                        enemyChar.isPlayer = false;
                        // Initialize status effects for battle
                        enemyChar.statusEffects = {
                            invisibility: { active: false, duration: 0 },
                            speedDebuff: { active: false, duration: 0, amount: 0 },
                            curse: { active: false, duration: 0 },
                            bloodRage: { active: false, damageBonus: 0 },
                            momentum: { speedStacks: 0 },
                            damageReduction: { active: false }
                        };
                        this.enemyTeam.push(enemyChar);
                    }
                } else {
                    this.enemyTeam = [];
                    for (let i = 0; i < 3; i++) {
                        const randomChar = availableCharacters[Math.floor(Math.random() * availableCharacters.length)];
                        const enemyChar = Object.assign(Object.create(Object.getPrototypeOf(randomChar)), randomChar);
                        enemyChar.hp = enemyChar.stats.maxHp;
                        enemyChar.isPlayer = false;
                        // Initialize status effects for battle
                        enemyChar.statusEffects = {
                            invisibility: { active: false, duration: 0 },
                            speedDebuff: { active: false, duration: 0, amount: 0 },
                            curse: { active: false, duration: 0 },
                            bloodRage: { active: false, damageBonus: 0 },
                            momentum: { speedStacks: 0 },
                            damageReduction: { active: false }
                        };
                        this.enemyTeam.push(enemyChar);
                        
                        // Remove from available to prevent duplicates
                        const index = availableCharacters.findIndex(char => char.id === randomChar.id);
                        availableCharacters.splice(index, 1);
                    }
                }
            }

            createTurnQueue() {
                // Initialize action bars for all alive characters
                const allCharacters = [...this.playerTeam, ...this.enemyTeam]
                    .filter(char => char.hp > 0);
                
                // Reset action bars
                this.actionBars = {};
                allCharacters.forEach(char => {
                    this.actionBars[this.getCharId(char)] = 0;
                });
                
                // Pre-calculate the next 20 turns for display
                this.calculateUpcomingTurns(20);
                
                // Set the initial turn queue for display
                this.turnQueue = this.upcomingTurns.slice(0, 6);
            }

            getCharId(character) {
                // Create unique ID for each character including team info
                return `${character.id}-${character.isPlayer ? 'P' : 'E'}`;
            }

            calculateUpcomingTurns(numberOfTurns) {
                const allCharacters = [...this.playerTeam, ...this.enemyTeam]
                    .filter(char => char.hp > 0);
                
                if (allCharacters.length === 0) {
                    this.upcomingTurns = [];
                    return;
                }
                
                // Clone current action bars for simulation
                const simActionBars = { ...this.actionBars };
                const turns = [];
                
                while (turns.length < numberOfTurns) {
                    // Increment all action bars by their effective speed (considering debuffs)
                    allCharacters.forEach(char => {
                        const charId = this.getCharId(char);
                        if (simActionBars[charId] !== undefined) {
                            simActionBars[charId] += char.getEffectiveSpeed();
                        }
                    });
                    
                    // Find characters that reached the threshold
                    const readyChars = allCharacters.filter(char => {
                        const charId = this.getCharId(char);
                        return simActionBars[charId] >= this.ACTION_THRESHOLD;
                    });
                    
                    if (readyChars.length > 0) {
                        // Sort by tie-breaking rules
                        readyChars.sort((a, b) => {
                            const aBar = simActionBars[this.getCharId(a)];
                            const bBar = simActionBars[this.getCharId(b)];
                            
                            // First tiebreaker: Higher action bar value
                            if (aBar !== bBar) return bBar - aBar;
                            
                            // Second tiebreaker: Lower base speed
                            if (a.stats.speed !== b.stats.speed) {
                                return a.stats.speed - b.stats.speed;
                            }
                            
                            // Third tiebreaker: Player advantage
                            if (a.isPlayer !== b.isPlayer) {
                                return a.isPlayer ? -1 : 1;
                            }
                            
                            // Fourth tiebreaker: Selection order (using array index)
                            const aIndex = a.isPlayer ? 
                                this.playerTeam.indexOf(a) : 
                                this.enemyTeam.indexOf(a);
                            const bIndex = b.isPlayer ? 
                                this.playerTeam.indexOf(b) : 
                                this.enemyTeam.indexOf(b);
                            return aIndex - bIndex;
                        });
                        
                        // Process each ready character
                        readyChars.forEach(char => {
                            const charId = this.getCharId(char);
                            simActionBars[charId] -= this.ACTION_THRESHOLD;
                            turns.push(char);
                        });
                    }
                }
                
                this.upcomingTurns = turns;
            }

            getCurrentCharacter() {
                if (this.upcomingTurns.length === 0) return null;
                return this.upcomingTurns[0];
            }

            nextTurn() {
                const currentChar = this.getCurrentCharacter();
                if (currentChar) {
                    const charId = this.getCharId(currentChar);
                    
                    // Actually consume the action bar for the character that just acted
                    this.actionBars[charId] -= this.ACTION_THRESHOLD;
                    
                    // Move to next turn
                    this.turnHistory.push(this.upcomingTurns.shift());
                    
                    // Calculate more turns if needed
                    if (this.upcomingTurns.length < 20) {
                        this.calculateUpcomingTurns(20);
                    }
                    
                    // Update the display queue (sliding window of 6)
                    this.turnQueue = this.upcomingTurns.slice(0, 6);
                }
                
                // Update status effects for all characters
                this.updateAllStatusEffects();
                
                // Process turn-start abilities for the next character
                const nextChar = this.getCurrentCharacter();
                if (nextChar) {
                    this.processTurnStartAbilities(nextChar);
                }
                
                // Update display
                this.updateBattleDisplay();
                
                if (nextChar && !nextChar.isPlayer) {
                    this.nextTurnTimer = setTimeout(() => {
                    this.nextTurnTimer = null;
                    this.processAITurn();
                }, 2500);
                } else if (nextChar && nextChar.isPlayer) {
                    // Re-enable attack buttons when it's the player's turn
                    this.attackButtonsDisabled = false;
                    this.isProcessingTurn = false;
                }
            }

            progressActionBars() {
                // Progress all action bars based on effective speed (considering debuffs)
                const allCharacters = [...this.playerTeam, ...this.enemyTeam]
                    .filter(char => char.hp > 0);
                
                allCharacters.forEach(char => {
                    const charId = this.getCharId(char);
                    if (this.actionBars[charId] !== undefined) {
                        this.actionBars[charId] += char.getEffectiveSpeed();
                    }
                });
                
                // Find who reached the threshold
                const readyCharacters = allCharacters.filter(char => {
                    const charId = this.getCharId(char);
                    return this.actionBars[charId] >= this.ACTION_THRESHOLD;
                });
                
                // Sort by tiebreaking rules and return
                if (readyCharacters.length > 0) {
                    readyCharacters.sort((a, b) => {
                        // Tiebreaker 1: Higher action bar value
                        const aBar = this.actionBars[this.getCharId(a)];
                        const bBar = this.actionBars[this.getCharId(b)];
                        if (aBar !== bBar) return bBar - aBar;
                        
                        // Tiebreaker 2: Higher base speed
                        if (a.stats.speed !== b.stats.speed) {
                            return a.stats.speed - b.stats.speed;
                        }
                        
                        // Tiebreaker 3: Player advantage
                        if (a.isPlayer !== b.isPlayer) {
                            return a.isPlayer ? -1 : 1;
                        }
                        
                        // Tiebreaker 4: Selection order
                        const aIndex = a.isPlayer ? 
                            this.playerTeam.indexOf(a) : 
                            this.enemyTeam.indexOf(a);
                        const bIndex = b.isPlayer ? 
                            this.playerTeam.indexOf(b) : 
                            this.enemyTeam.indexOf(b);
                        return aIndex - bIndex;
                    });
                    
                    return readyCharacters[0];
                }
                
                return null;
            }

            updateTurnQueue() {
                // Remove defeated characters from action bars
                const allCharacters = [...this.playerTeam, ...this.enemyTeam];
                allCharacters.forEach(char => {
                    if (char.hp <= 0) {
                        const charId = this.getCharId(char);
                        delete this.actionBars[charId];
                    }
                });
                
                // Recalculate upcoming turns
                this.calculateUpcomingTurns(20);
                this.turnQueue = this.upcomingTurns.slice(0, 6);
            }

            async processTurn(attackObj, targetCharacter) {
                // Prevent multiple attacks in one turn
                if (this.isProcessingTurn) {
                    return;
                }
                
                this.isProcessingTurn = true;
                
                const attacker = this.getCurrentCharacter();
                if (!attacker || attacker.hp <= 0) {
                    this.isProcessingTurn = false;
                    this.nextTurn();
                    return;
                }

                if (attackObj.type === 'splash') {
                    await this.processSplashAttack(attacker, attackObj.gene);
                } else {
                    await this.processSingleAttack(attacker, attackObj.gene, targetCharacter);
                }
                
                // Check for battle end
                if (this.checkBattleEnd()) {
                    this.isProcessingTurn = false;
                    return;
                }
                
                this.nextTurn();
                this.isProcessingTurn = false;
            }

            async processSingleAttack(attacker, attackGene, targetCharacter) {
                // Check if target is invisible (untargetable)
                if (targetCharacter.isInvisible()) {
                    const teamClass = attacker.isPlayer ? 'player-attack' : 'enemy-attack';
                    this.addBattleLog(` ${attacker.id}'s attack missed ${targetCharacter.id} (invisible)!`, `not-very-effective ${teamClass}`);
                    return;
                }

                // Apply curse damage reduction to attacker
                const damageMultiplier = attacker.getDamageMultiplier();
                
                // Calculate base damage with rage bonus
                const baseDamage = attacker.stats.attack;
                const effectiveness = attacker.getEffectiveness(attackGene, targetCharacter);
                let finalDamage = baseDamage * effectiveness * damageMultiplier;
                
                // Apply Orange's Molten Armor damage reduction
                const originalDamage = finalDamage;
                finalDamage = targetCharacter.applyDamageReduction(finalDamage);
                
                // Apply damage
                targetCharacter.hp = Math.max(0, targetCharacter.hp - finalDamage);
                
                // Get attack and defense gene symbols
                const attackSymbol = attackGene === 'Neutral' ? '' : GENE_SYMBOLS[attackGene];
                const defenseSymbols = targetCharacter.genes.map(gene => GENE_SYMBOLS[gene]).join('');
                
                // Create detailed log message with effectiveness stacking
                let effectivenessText = '';
                let logClass = 'damage';
                let totalEffectiveness = effectiveness;
                
                // Add Blood Rage bonus if active
                if (attacker.statusEffects.bloodRage.active) {
                    totalEffectiveness += 0.25;
                }
                
                // Apply curse reduction if active
                if (attacker.statusEffects.curse.active) {
                    totalEffectiveness *= 0.75;
                }
                
                // Determine effectiveness display
                if (totalEffectiveness >= 1.75) {
                    effectivenessText = `Extremely effective (+${Math.round((totalEffectiveness - 1) * 100)}%)`;
                    logClass = 'super-effective';
                } else if (totalEffectiveness >= 1.5) {
                    effectivenessText = `Very effective (+${Math.round((totalEffectiveness - 1) * 100)}%)`;
                    logClass = 'super-effective';
                } else if (totalEffectiveness >= 1.25) {
                    effectivenessText = `Effective (+${Math.round((totalEffectiveness - 1) * 100)}%)`;
                    logClass = 'super-effective';
                } else if (totalEffectiveness <= 0.25) {
                    effectivenessText = `Extremely weak (-${Math.round((1 - totalEffectiveness) * 100)}%)`;
                    logClass = 'not-very-effective';
                } else if (totalEffectiveness <= 0.5) {
                    effectivenessText = `Not effective at all (-${Math.round((1 - totalEffectiveness) * 100)}%)`;
                    logClass = 'not-very-effective';
                } else if (totalEffectiveness <= 0.75) {
                    effectivenessText = `Not too effective (-${Math.round((1 - totalEffectiveness) * 100)}%)`;
                    logClass = 'not-very-effective';
                } else {
                    effectivenessText = `Normal damage`;
                }
                
                // Add curse effect to log if applicable
                if (damageMultiplier < 1.0) {
                    effectivenessText += ` | Cursed (-25%)`;
                }
                
                // Add damage reduction to log if applicable
                if (finalDamage < originalDamage) {
                    effectivenessText += ` | Armor (-${originalDamage - finalDamage})`;
                }
                
                // Add Blood Rage effect to log if applicable
                if (attacker.statusEffects.bloodRage.active) {
                    effectivenessText += ` | Blood Rage (+25%)`;
                }
                
                const detailedLog = `${attacker.id} (${attackSymbol}${attackGene})  ${targetCharacter.id} (${defenseSymbols}${targetCharacter.genes.join('-')}) | Base: ${baseDamage}  ${totalEffectiveness.toFixed(2)} = ${finalDamage} dmg | ${effectivenessText}`;
                
                // Color code based on team
                const teamClass = attacker.isPlayer ? 'player-attack' : 'enemy-attack';
                this.addBattleLog(detailedLog, `${logClass} ${teamClass}`);
                
                this.showDamageAnimation(targetCharacter, finalDamage, effectiveness, attacker);
                
                // Trigger Green's Thorn Skin reflection
                const reflectedDamage = targetCharacter.triggerThornSkin(attacker, finalDamage);
                if (reflectedDamage > 0) {
                    attacker.hp = Math.max(0, attacker.hp - reflectedDamage);
                    this.addBattleLog(` ${targetCharacter.id}'s Thorn Skin reflects ${reflectedDamage} damage back to ${attacker.id}!`, `super-effective ${teamClass}`);
                    this.showDamageAnimation(attacker, reflectedDamage, 1.0);
                }
                
                // Trigger Red's Blood Rage if HP drops below 75%
                if (targetCharacter.triggerBloodRage()) {
                    this.addBattleLog(` ${targetCharacter.id} enters Blood Rage! +25% damage effectiveness and invisibility for 2 turns!`, `super-effective ${teamClass}`);
                }
                
                // Trigger Blue's Momentum when attacked
                if (targetCharacter.triggerMomentum()) {
                    this.addBattleLog(` ${targetCharacter.id} gains momentum! +8 speed (now ${targetCharacter.getEffectiveSpeed()})`, `super-effective ${teamClass}`);
                }
                
                // Apply Purple's Hex Mark curse
                if (attacker.applyCurse(targetCharacter)) {
                    this.addBattleLog(` ${attacker.id}'s Hex Mark curses ${targetCharacter.id}! -25% damage next turn!`, `super-effective ${teamClass}`);
                }
                
                if (targetCharacter.hp <= 0) {
                    this.addBattleLog(` ${targetCharacter.id} was defeated!`, `damage ${teamClass}`);
                    this.updateTurnQueue();
                }
            }

            async processSplashAttack(attacker, attackGene) {
                // Target the ENEMY team, not own team
                const targets = attacker.isPlayer ? 
                    this.enemyTeam.filter(char => char.hp > 0 && !char.isInvisible()).slice(0, 3) :
                    this.playerTeam.filter(char => char.hp > 0 && !char.isInvisible()).slice(0, 3);
                    
                const teamClass = attacker.isPlayer ? 'player-attack' : 'enemy-attack';
                this.addBattleLog(` ${attacker.id} uses ${GENE_SYMBOLS[attackGene]} ${attackGene} Splash Attack!`, `super-effective ${teamClass}`);
                
                for (const target of targets) {
                    // Apply curse damage reduction to attacker
                    const damageMultiplier = attacker.getDamageMultiplier();
                    
                    const baseDamage = attacker.stats.attack;
                    let effectiveness = attacker.getEffectiveness(attackGene, target);
                    
                    // Apply Blood Rage damage bonus if active
                    if (attacker.statusEffects.bloodRage.active) {
                        effectiveness += 0.25; // +25% damage effectiveness
                    }
                    
                    // Apply curse damage reduction if active
                    if (attacker.statusEffects.curse.active) {
                        effectiveness *= 0.75; // -25% damage effectiveness
                    }
                    
                    const singleDamage = baseDamage * effectiveness * damageMultiplier;
                    let splashDamage = singleDamage / 2;
                    
                    // Apply Orange's Molten Armor damage reduction
                    const originalDamage = splashDamage;
                    splashDamage = target.applyDamageReduction(splashDamage);
                    
                    target.hp = Math.max(0, target.hp - splashDamage);
                    
                    const defenseSymbols = target.genes.map(gene => GENE_SYMBOLS[gene]).join('');
                    let effectivenessText = `Base: ${baseDamage}  ${effectiveness.toFixed(2)}  2 = ${splashDamage} dmg`;
                    
                    // Add curse effect to log if applicable
                    if (damageMultiplier < 1.0) {
                        effectivenessText += ` | Cursed (-25%)`;
                    }
                    
                    // Add damage reduction to log if applicable
                    if (splashDamage < originalDamage) {
                        effectivenessText += ` | Armor (-${originalDamage - splashDamage})`;
                    }
                    
                    // Add Blood Rage effect to log if applicable
                    if (attacker.statusEffects.bloodRage.active) {
                        effectivenessText += ` | Blood Rage (+25%)`;
                    }
                    
                    const detailedLog = `${attacker.id} (${GENE_SYMBOLS[attackGene]}${attackGene}) SPLASH  ${target.id} (${defenseSymbols}${target.genes.join('-')}) | ${effectivenessText}`;
                    
                    this.addBattleLog(detailedLog, `damage ${teamClass}`);
                    this.showDamageAnimation(target, splashDamage, effectiveness, attacker);
                    
                    // Trigger Green's Thorn Skin reflection
                    const reflectedDamage = target.triggerThornSkin(attacker, splashDamage);
                    if (reflectedDamage > 0) {
                        attacker.hp = Math.max(0, attacker.hp - reflectedDamage);
                        this.addBattleLog(` ${target.id}'s Thorn Skin reflects ${reflectedDamage} damage back to ${attacker.id}!`, `super-effective ${teamClass}`);
                        this.showDamageAnimation(attacker, reflectedDamage, 1.0);
                    }
                    
                    // Trigger Red's Blood Rage if HP drops below 75%
                    if (target.triggerBloodRage()) {
                        this.addBattleLog(` ${target.id} enters Blood Rage! +25% damage effectiveness and invisibility for 2 turns!`, `super-effective ${teamClass}`);
                    }
                    
                    // Trigger Blue's Momentum when attacked
                    if (target.triggerMomentum()) {
                        this.addBattleLog(` ${target.id} gains momentum! +8 speed (now ${target.getEffectiveSpeed()})`, `super-effective ${teamClass}`);
                    }
                    
                    // Apply Purple's Hex Mark curse
                    if (attacker.applyCurse(target)) {
                        this.addBattleLog(` ${attacker.id}'s Hex Mark curses ${target.id}! -25% damage next turn!`, `super-effective ${teamClass}`);
                    }
                    
                    if (target.hp <= 0) {
                        this.addBattleLog(` ${target.id} was defeated!`, `damage ${teamClass}`);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                this.updateTurnQueue();
            }

            processAITurn() {
                const attacker = this.getCurrentCharacter();
                const availableTargets = this.playerTeam.filter(char => char.hp > 0);
                
                if (availableTargets.length === 0) return;
                
                // Check if all targets are invisible
                const visibleTargets = availableTargets.filter(target => !target.isInvisible());
                if (visibleTargets.length === 0) {
                    this.addBattleLog(` ${attacker.id} has no visible targets to attack!`, 'enemy-attack');
                    this.nextTurn();
                    return;
                }
                
                let selectedAttack, selectedTarget;
                
                // Add "AI is thinking..." message
                this.addBattleLog(` ${attacker.id} is thinking...`, 'enemy-attack');
                
                // Delay the AI decision by 2 seconds
                this.aiTurnTimer = setTimeout(() => {
                // Clear the timer reference since it's about to execute
                this.aiTurnTimer = null;
                
                switch(this.difficulty) {
                        case 'easy':
                            // Random everything
                            const attackObjs = attacker.getAttackGenes();
                            selectedAttack = attackObjs[Math.floor(Math.random() * attackObjs.length)];
                            selectedTarget = visibleTargets[Math.floor(Math.random() * visibleTargets.length)];
                            break;
                            
                        case 'normal':
                            // 50% chance to make smart move, 50% random
                            if (Math.random() < 0.5) {
                                const bestMove = this.calculateBestMove(attacker, visibleTargets);
                                selectedAttack = bestMove.attack;
                                selectedTarget = bestMove.target;
                            } else {
                                const attackObjs = attacker.getAttackGenes();
                                selectedAttack = attackObjs[Math.floor(Math.random() * attackObjs.length)];
                                selectedTarget = visibleTargets[Math.floor(Math.random() * visibleTargets.length)];
                            }
                            break;
                            
                        case 'hard':
                            // 80% chance to make smart move
                            if (Math.random() < 0.8) {
                                const bestMove = this.calculateBestMove(attacker, visibleTargets);
                                selectedAttack = bestMove.attack;
                                selectedTarget = bestMove.target;
                            } else {
                                const attackObjs = attacker.getAttackGenes();
                                selectedAttack = attackObjs[Math.floor(Math.random() * attackObjs.length)];
                                selectedTarget = visibleTargets[Math.floor(Math.random() * visibleTargets.length)];
                            }
                            break;
                            
                        case 'extreme':
                            // Always make the optimal move
                            const bestMove = this.calculateBestMove(attacker, visibleTargets);
                            selectedAttack = bestMove.attack;
                            selectedTarget = bestMove.target;
                            break;
                    }
                    
                    this.processTurn(selectedAttack, selectedTarget);
                }, 2000); // 2 second delay
            }

            calculateBestMove(attacker, availableTargets) {
                // Filter out invisible targets
                const visibleTargets = availableTargets.filter(target => !target.isInvisible());
                
                if (visibleTargets.length === 0) {
                    // If no visible targets, return a default move (will be handled by processAITurn)
                    return null;
                }
                
                const attackObjs = attacker.getAttackGenes();
                let bestMove = null;
                let bestScore = -Infinity;
                
                for (const attackObj of attackObjs) {
                    if (attackObj.type === 'splash') {
                        // Calculate total damage for splash attack
                        let totalDamage = 0;
                        let willKillCount = 0;
                        
                        for (const target of visibleTargets) {
                            const effectiveness = attacker.getEffectiveness(attackObj.gene, target);
                            const damage = (attacker.stats.attack * effectiveness) / 2; // Splash is half damage
                            totalDamage += damage;
                            
                            if (damage >= target.hp) {
                                willKillCount += 2; // Bonus for potential kills
                            }
                        }
                        
                        // Score based on total damage and kills
                        const score = totalDamage + (willKillCount * 100);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = { attack: attackObj, target: visibleTargets[0] }; // Target doesn't matter for splash
                        }
                    } else {
                        // Calculate best target for single attacks
                        for (const target of visibleTargets) {
                            const effectiveness = attackObj.gene === 'Neutral' ? 1 : attacker.getEffectiveness(attackObj.gene, target);
                            const damage = attacker.stats.attack * effectiveness;
                            
                            // Scoring factors:
                            let score = damage; // Base score is damage dealt
                            
                            // Huge bonus for finishing off an enemy
                            if (damage >= target.hp) {
                                score += 500;
                            }
                            
                            // Bonus for hitting low HP enemies (to finish them next turn)
                            if (target.hp <= attacker.stats.attack * 1.5) {
                                score += 100;
                            }
                            
                            // Bonus for super effective moves
                            if (effectiveness >= 1.25) {
                                score += 50 * effectiveness;
                            }
                            
                            // Small penalty for not very effective moves
                            if (effectiveness <= 0.75) {
                                score -= 25;
                            }
                            
                            // Consider threat level (enemy's attack power)
                            score += target.stats.attack * 0.3;
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestMove = { attack: attackObj, target: target };
                            }
                        }
                    }
                }
                
                return bestMove || { 
                    attack: attackObjs[0], 
                    target: visibleTargets[0] 
                };
            }

            checkBattleEnd() {
                const playerAlive = this.playerTeam.some(char => char.hp > 0);
                const enemyAlive = this.enemyTeam.some(char => char.hp > 0);
                
                if (!playerAlive || !enemyAlive) {
                    this.endBattle(playerAlive);
                    return true;
                }
                return false;
            }

            endBattle(playerWon) {
                this.clearAllTimers(); // Add this line
                this.battlePhase = 'ended';
                this.isProcessingTurn = false; // Reset the flag
                this.attackButtonsDisabled = false; // Reset attack buttons
                const message = playerWon ? 'Victory! You won the battle!' : 'Defeat! Better luck next time!';
                const teamClass = playerWon ? 'player-attack' : 'enemy-attack';
                this.addBattleLog(message, `super-effective ${teamClass}`);
                
                setTimeout(() => {
                    alert(message);
                    this.returnToSetup();
                }, 2000);
            }

            returnToSetup() {
                // Clear all running timers first!
                this.clearAllTimers();
                
                document.getElementById('team-setup').style.display = 'block';
                document.getElementById('battle-arena').style.display = 'none';
                
                // Reset battle log
                this.battleLog = [];
                const logElement = document.getElementById('battleLog');
                if (logElement) {
                    logElement.innerHTML = '';
                }
                
                this.game.battleSystem = new BattleSystem(this.game);
                this.game.selectedBattleTeam = [];
                this.game.updateBattleTeamSelection();
            }

            showAttackAnimation(attacker, target) {
                return new Promise(resolve => {
                    // Highlight attacker
                    const attackerElement = document.querySelector(`[data-battle-char="${attacker.id}"]`);
                    const targetElement = document.querySelector(`[data-battle-char="${target.id}"]`);
        
                    if (attackerElement) {
                        attackerElement.style.boxShadow = '0 0 20px #ffeb3b';
                        attackerElement.style.transform = 'scale(1.1)';
                    }
                    
                    setTimeout(() => {
                        // Highlight target
                        if (targetElement) {
                            targetElement.style.boxShadow = '0 0 20px #ff6b6b';
                        }
                        
                        setTimeout(() => {
                            // Reset styles
                            if (attackerElement) {
                                attackerElement.style.boxShadow = '';
                                attackerElement.style.transform = '';
                            }
                            if (targetElement) {
                                targetElement.style.boxShadow = '';
                            }
                            resolve();
                        }, 800);
                    }, 500);
                });
            }

            showDamageAnimation(targetCharacter, damage, effectiveness, attacker = null) {
                // Use both character ID and team to create unique selector
                const teamPrefix = targetCharacter.isPlayer ? 'player' : 'enemy';
                const targetElement = document.querySelector(`[data-battle-char="${targetCharacter.id}"][data-team="${teamPrefix}"]`);
                if (!targetElement) return;
                
                // Create damage number element
                const damageNum = document.createElement('div');
                damageNum.className = 'damage-number damage-animation';
                
                // Add effectiveness indicator with emote and percentage
                let effectivenessIndicator = '';
                let totalEffectiveness = effectiveness;
                
                // Add Blood Rage bonus if active
                if (attacker.statusEffects.bloodRage.active) {
                    totalEffectiveness += 0.25;
                }
                
                // Apply curse reduction if active
                if (attacker.statusEffects.curse.active) {
                    totalEffectiveness *= 0.75;
                }
                
                if (totalEffectiveness >= 1.75) {
                    effectivenessIndicator = ` (+${Math.round((totalEffectiveness - 1) * 100)}%)`;
                    damageNum.classList.add('extremely-effective');
                } else if (totalEffectiveness >= 1.5) {
                    effectivenessIndicator = ` (+${Math.round((totalEffectiveness - 1) * 100)}%)`;
                    damageNum.classList.add('super-effective');
                } else if (totalEffectiveness >= 1.25) {
                    effectivenessIndicator = ` (+${Math.round((totalEffectiveness - 1) * 100)}%)`;
                    damageNum.classList.add('super-effective');
                } else if (totalEffectiveness <= 0.25) {
                    effectivenessIndicator = ` (-${Math.round((1 - totalEffectiveness) * 100)}%)`;
                    damageNum.classList.add('extremely-weak');
                } else if (totalEffectiveness <= 0.5) {
                    effectivenessIndicator = ` (-${Math.round((1 - totalEffectiveness) * 100)}%)`;
                    damageNum.classList.add('not-very-effective');
                } else if (totalEffectiveness <= 0.75) {
                    effectivenessIndicator = ` (-${Math.round((1 - totalEffectiveness) * 100)}%)`;
                    damageNum.classList.add('not-very-effective');
                }
                
                damageNum.textContent = damage + effectivenessIndicator;
                
                const rect = targetElement.getBoundingClientRect();
                damageNum.style.position = 'fixed';
                damageNum.style.left = (rect.left + rect.width / 2) + 'px';
                damageNum.style.top = rect.top + 'px';
                damageNum.style.zIndex = '1000';
                
                document.body.appendChild(damageNum);
                
                setTimeout(() => {
                    if (damageNum.parentNode) {
                        damageNum.remove();
                    }
                }, 2500);
                
                targetElement.classList.add('battle-shake');
                const shakeIntensity = Math.min(damage / 50, 1);
                targetElement.style.setProperty('--shake-intensity', shakeIntensity);
                
                setTimeout(() => {
                    targetElement.classList.remove('battle-shake');
                    targetElement.style.removeProperty('--shake-intensity');
                }, 600);
                
                setTimeout(() => this.updateBattleDisplay(), 200);
            }

            addBattleLog(message, className = '') {
                this.battleLog.push({ message, className });
                if (this.battleLog.length > 10) {
                    this.battleLog.shift();
                }
                
                const logElement = document.getElementById('battleLog');
                if (logElement) {
                    logElement.innerHTML = this.battleLog
                        .map(log => `<div class="log-entry ${log.className}">${log.message}</div>`)
                        .join('');
                    logElement.scrollTop = logElement.scrollHeight;
                }
            }

            renderBattleArena() {
                document.getElementById('team-setup').style.display = 'none';
                document.getElementById('battle-arena').style.display = 'block';
                
                this.updateBattleDisplay();
                
                // Add quit button listener
                const quitBtn = document.getElementById('quitBattleBtn');
                if (quitBtn) {
                    // Remove any existing listeners first
                    quitBtn.replaceWith(quitBtn.cloneNode(true));
                    const newQuitBtn = document.getElementById('quitBattleBtn');
                    newQuitBtn.addEventListener('click', () => this.showQuitConfirmation());
                }
            }

            updateBattleDisplay() {
                this.updateTeamDisplays();
                this.updateTurnOrder();
                this.updateBattleControls();
            }

            updateTeamDisplays() {
                // Update player team
                const playerDisplay = document.getElementById('playerTeamDisplay');
                playerDisplay.innerHTML = '';
                this.playerTeam.forEach(char => {
                    const charElement = this.createBattleCharacterElement(char);
                    playerDisplay.appendChild(charElement);
                });
                
                // Update enemy team
                const enemyDisplay = document.getElementById('enemyTeamDisplay');
                enemyDisplay.innerHTML = '';
                this.enemyTeam.forEach(char => {
                    const charElement = this.createBattleCharacterElement(char);
                    enemyDisplay.appendChild(charElement);
                });
            }

            createBattleCharacterElement(character) {
                const div = document.createElement('div');
                div.className = 'battle-character';
                div.dataset.battleChar = character.id;
                div.dataset.team = character.isPlayer ? 'player' : 'enemy'; // Add team identifier
                
                if (character.hp <= 0) {
                    div.classList.add('defeated');
                }
                
                const currentChar = this.getCurrentCharacter();
                if (currentChar && currentChar.id === character.id) {
                    div.classList.add('active');
                }
                
                // Add status effect CSS classes
                if (character.isInvisible()) {
                    div.classList.add('invisible');
                }
                if (character.statusEffects.bloodRage.active) {
                    div.classList.add('rage');
                }
                if (character.isCursed()) {
                    div.classList.add('cursed');
                }
                if (character.statusEffects.speedDebuff.active) {
                    div.classList.add('speed-debuff');
                }
                if (character.statusEffects.momentum.speedStacks > 0) {
                    div.classList.add('momentum');
                }
                if (character.specialAbility && character.specialAbility.effect === 'damage_reduction') {
                    div.classList.add('armor');
                }
                if (character.specialAbility && character.specialAbility.effect === 'reflection') {
                    div.classList.add('thorn');
                }
                
                const sprite = document.createElement('div');
                sprite.className = 'battle-sprite';
                this.game.updateCharacterSprite(sprite, character);
                
                // Add ability icon if character has a special ability
                if (character.specialAbility) {
                    const abilityIcon = document.createElement('div');
                    abilityIcon.className = 'ability-icon';
                    abilityIcon.style.cssText = `
                        position: absolute;
                        top: -5px;
                        right: -5px;
                        width: 20px;
                        height: 20px;
                        background: rgba(255, 255, 255, 0.9);
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        border: 2px solid #4ecdc4;
                        z-index: 10;
                    `;
                    
                    // Set ability icon based on gene type
                    const abilityGene = character.genes.length === 1 ? character.genes[0] : character.genes[1];
                    abilityIcon.textContent = GENE_SYMBOLS[abilityGene];
                    abilityIcon.title = character.getAbilityName();
                    
                    sprite.appendChild(abilityIcon);
                }
                
                const stats = document.createElement('div');
                stats.className = 'character-stats';
                
                // Show effective speed with momentum stacks
                const effectiveSpeed = character.getEffectiveSpeed();
                const momentumStacks = character.statusEffects.momentum.speedStacks;
                let speedText = ` ${character.stats.speed}`;
                if (momentumStacks > 0) {
                    speedText = ` ${effectiveSpeed} (+${momentumStacks * 8})`;
                } else if (effectiveSpeed !== character.stats.speed) {
                    speedText = ` ${effectiveSpeed} (${character.stats.speed})`;
                }
                
                // Show attack with effectiveness modifiers
                let attackText = ` ${character.stats.attack}`;
                if (character.statusEffects.bloodRage.active) {
                    attackText = ` ${character.stats.attack} (+25%)`;
                }
                if (character.statusEffects.curse.active) {
                    attackText = ` ${character.stats.attack} (-25%)`;
                }
                
                stats.innerHTML = `
                    <div>${character.id}</div>
                    <div> <strong>${character.hp}</strong>/${character.stats.maxHp}</div>
                    <div>${attackText} | ${speedText}</div>
                `;
                
                // Add status effect indicators
                const statusEffects = document.createElement('div');
                statusEffects.className = 'status-effects';
                statusEffects.style.cssText = `
                    display: flex;
                    gap: 2px;
                    justify-content: center;
                    margin-top: 4px;
                `;
                
                if (character.isInvisible()) {
                    const invisIcon = document.createElement('span');
                    invisIcon.textContent = '';
                    invisIcon.title = 'Invisible (untargetable)';
                    invisIcon.style.fontSize = '12px';
                    statusEffects.appendChild(invisIcon);
                }
                
                if (character.isCursed()) {
                    const curseIcon = document.createElement('span');
                    curseIcon.textContent = '';
                    curseIcon.title = 'Cursed (-25% damage)';
                    curseIcon.style.fontSize = '12px';
                    statusEffects.appendChild(curseIcon);
                }
                
                if (character.statusEffects.bloodRage.active) {
                    const rageIcon = document.createElement('span');
                    rageIcon.textContent = '';
                    rageIcon.title = 'Blood Rage (+25% damage effectiveness)';
                    rageIcon.style.fontSize = '12px';
                    statusEffects.appendChild(rageIcon);
                }
                
                if (character.statusEffects.speedDebuff.active) {
                    const debuffIcon = document.createElement('span');
                    debuffIcon.textContent = '';
                    debuffIcon.title = `Speed reduced by ${character.statusEffects.speedDebuff.amount}`;
                    debuffIcon.style.fontSize = '12px';
                    statusEffects.appendChild(debuffIcon);
                }
                
                if (character.statusEffects.momentum.speedStacks > 0) {
                    const momentumIcon = document.createElement('span');
                    momentumIcon.textContent = '';
                    momentumIcon.title = `Momentum: +${character.statusEffects.momentum.speedStacks * 8} speed`;
                    momentumIcon.style.fontSize = '12px';
                    statusEffects.appendChild(momentumIcon);
                }
                
                if (character.specialAbility && character.specialAbility.effect === 'damage_reduction') {
                    const armorIcon = document.createElement('span');
                    armorIcon.textContent = '';
                    armorIcon.title = 'Molten Armor (-16 damage)';
                    armorIcon.style.fontSize = '12px';
                    statusEffects.appendChild(armorIcon);
                }
                
                if (character.specialAbility && character.specialAbility.effect === 'reflection') {
                    const thornIcon = document.createElement('span');
                    thornIcon.textContent = '';
                    thornIcon.title = 'Thorn Skin (50% reflection)';
                    thornIcon.style.fontSize = '12px';
                    statusEffects.appendChild(thornIcon);
                }
                
                const healthBar = document.createElement('div');
                healthBar.className = 'health-bar';
                const healthFill = document.createElement('div');
                healthFill.className = 'health-fill';
                const healthPercent = (character.hp / character.stats.maxHp) * 100;
                healthFill.style.width = `${healthPercent}%`;
                healthBar.appendChild(healthFill);
                
                div.appendChild(sprite);
                div.appendChild(stats);
                div.appendChild(statusEffects);
                div.appendChild(healthBar);
                
                return div;
            }

            updateTurnOrder() {
                const turnOrderList = document.getElementById('turnOrderList');
                turnOrderList.innerHTML = '';
                
                this.turnQueue.forEach((char, index) => {
                    const indicator = document.createElement('div');
                    indicator.className = 'turn-indicator';
                    indicator.classList.add(char.isPlayer ? 'player' : 'enemy');
                    
                    if (index === this.currentTurnIndex % this.turnQueue.length) {
                        indicator.classList.add('active');
                    }
                    
                    // Show gene emotes instead of text
                    if (char.genes.length === 1) {
                        indicator.textContent = GENE_SYMBOLS[char.genes[0]];
                    } else {
                        indicator.innerHTML = `<span style="font-size: 10px;">${GENE_SYMBOLS[char.genes[0]]}${GENE_SYMBOLS[char.genes[1]]}</span>`;
                    }
                    
                    turnOrderList.appendChild(indicator);
                });
            }

            updateBattleControls() {
                const currentChar = this.getCurrentCharacter();
                const controlsElement = document.getElementById('battleControls');
                const activeNameElement = document.getElementById('activeCharacterName');
                const attackButtonsElement = document.getElementById('attackButtons');
                
                if (!currentChar) return;
                
                activeNameElement.textContent = currentChar.id;

                // Ensure quit button exists and has proper event listener
                const quitBtn = document.getElementById('quitBattleBtn');

                if (currentChar.isPlayer) {
                    controlsElement.style.display = 'block';
                    
                    // Hide damage preview on mobile
                    const isMobile = window.innerWidth <= 768;
                    if (isMobile) {
                        attackButtonsElement.innerHTML = '<div style="margin-bottom: 10px; color: #666; font-size: 14px; font-weight: 500;">Select an attack:</div>';
                    } else {
                        attackButtonsElement.innerHTML = '<div style="margin-bottom: 15px; color: #666;">Select an attack:</div>';
                    }
                    
                    const attackObjs = currentChar.getAttackGenes();
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.display = 'flex';
                    buttonContainer.style.gap = isMobile ? '12px' : '15px';
                    buttonContainer.style.justifyContent = 'center';
                    buttonContainer.style.flexWrap = 'wrap';
                    
                    attackObjs.forEach((attackObj, index) => {
                        const button = document.createElement('button');
                        button.className = 'attack-btn';
                        
                        // Disable button if attack buttons are disabled
                        if (this.attackButtonsDisabled) {
                            button.disabled = true;
                        }
                        
                        if (attackObj.type === 'splash') {
                            button.textContent = `${attackObj.gene} Splash `;
                            button.style.setProperty('--attack-color', GENE_DARK_COLORS[attackObj.gene]);
                            button.style.setProperty('--attack-color-light', GENE_COLORS[attackObj.gene]);
                        } else {
                            button.textContent = attackObj.gene;
                            if (attackObj.gene !== 'Neutral') {
                                button.style.setProperty('--attack-color', GENE_COLORS[attackObj.gene]);
                                button.style.setProperty('--attack-color-light', GENE_LIGHT_COLORS[attackObj.gene]);
                            } else {
                                button.style.setProperty('--attack-color', '#999');
                                button.style.setProperty('--attack-color-light', '#bbb');
                            }
                        }
                        
                        button.addEventListener('click', () => this.selectAttackGene(attackObj));
                        buttonContainer.appendChild(button);
                    });

                    attackButtonsElement.appendChild(buttonContainer);
                } else {
                    controlsElement.style.display = 'block';
                    attackButtonsElement.innerHTML = '<div style="text-align: center; color: #666;">Enemy is thinking...</div>';
                }
            }

            selectAttackGene(attackObj) {
                // Prevent selecting attack if already processing a turn or buttons are disabled
                if (this.isProcessingTurn || this.attackButtonsDisabled) {
                    return;
                }
                
                // Disable attack buttons immediately after clicking
                this.attackButtonsDisabled = true;
                this.updateBattleControls(); // Refresh the UI to show disabled state
                
                this.selectedAttackObj = attackObj;
                this.showTargetSelection();
            }

            showTargetSelection() {
                const attackButtonsElement = document.getElementById('attackButtons');
                
                // For splash attacks, don't show target selection - just execute immediately
                if (this.selectedAttackObj.type === 'splash') {
                    this.processTurn(this.selectedAttackObj, null);
                    return;
                }
                
                const availableTargets = this.enemyTeam.filter(char => char.hp > 0 && !char.isInvisible());
                
                attackButtonsElement.innerHTML = '<div style="margin-bottom: 15px; color: #666; font-weight: bold; text-align: center; padding: 0 10px;">Select a target:</div>';
                
                const targetContainer = document.createElement('div');
                targetContainer.style.display = 'flex';
                
                // Mobile-optimized gap for target container
                const isMobile = window.innerWidth <= 768;
                targetContainer.style.gap = isMobile ? '6px' : '8px';
                
                targetContainer.style.justifyContent = 'center';
                targetContainer.style.flexWrap = 'wrap';
                targetContainer.style.width = '100%';
                
                availableTargets.forEach(target => {
                    const button = document.createElement('button');
                    button.className = 'attack-btn';

                    // Use target's gene colors for the button
                    if (target.genes.length === 1) {
                        button.style.background = `linear-gradient(45deg, ${GENE_COLORS[target.genes[0]]}, ${GENE_LIGHT_COLORS[target.genes[0]]})`;
                    } else if (target.genes[0] === target.genes[1]) {
                        const geneColor = GENE_COLORS[target.genes[0]];
                        const darkColor = GENE_DARK_COLORS[target.genes[0]];
                        button.style.background = `linear-gradient(45deg, ${geneColor}, ${darkColor}, ${geneColor})`;
                    } else {
                        button.style.background = `linear-gradient(45deg, ${GENE_COLORS[target.genes[0]]}, ${GENE_COLORS[target.genes[1]]})`;
                    }
                    
                    button.textContent = target.id;
                    button.style.color = 'white';
                    button.style.textShadow = '1px 1px 2px rgba(0, 0, 0, 0.7)';
                    
                    // Mobile-optimized sizing for target buttons
                    const isMobile = window.innerWidth <= 768;
                    if (isMobile) {
                        button.style.minWidth = '100px';
                        button.style.maxWidth = '120px';
                        button.style.flex = '1 1 100px';
                        button.style.fontSize = '12px';
                        button.style.padding = '10px 12px';
                    } else {
                        button.style.minWidth = '120px';
                        button.style.maxWidth = '140px';
                        button.style.flex = '1 1 120px';
                    }
                    
                    button.addEventListener('click', async () => {
                        // Prevent multiple clicks during turn processing
                        if (this.isProcessingTurn) {
                            return;
                        }
                        
                        // Disable all target buttons immediately after clicking
                        const allTargetButtons = targetContainer.querySelectorAll('button');
                        allTargetButtons.forEach(btn => btn.disabled = true);
                        
                        await this.showAttackAnimation(this.getCurrentCharacter(), target);
                        this.processTurn(this.selectedAttackObj, target);
                    });
                    
                    targetContainer.appendChild(button);
                });
                
                attackButtonsElement.appendChild(targetContainer);
            }

            handlePlayerAttack(attackGene) {
                const availableTargets = this.enemyTeam.filter(char => char.hp > 0);
                if (availableTargets.length === 0) return;
                
                // For now, attack a random target (could be enhanced with target selection)
                const target = availableTargets[Math.floor(Math.random() * availableTargets.length)];
                this.processTurn(attackGene, target);
            }

            updateAllStatusEffects() {
                const allCharacters = [...this.playerTeam, ...this.enemyTeam];
                allCharacters.forEach(char => {
                    char.updateStatusEffects();
                });
            }

            processTurnStartAbilities(character) {
                // Process Yellow's Solar Recovery
                const healAmount = character.healFromSolarRecovery();
                if (healAmount > 0) {
                    const teamClass = character.isPlayer ? 'player-attack' : 'enemy-attack';
                    this.addBattleLog(` ${character.id}'s Solar Recovery heals ${healAmount} HP!`, `super-effective ${teamClass}`);
                    
                    // Show healing animation
                    this.showHealingAnimation(character, healAmount);
                }
                
                // Process Blue's Momentum at turn start
                if (character.triggerMomentum()) {
                    const teamClass = character.isPlayer ? 'player-attack' : 'enemy-attack';
                    this.addBattleLog(` ${character.id}'s Momentum gains +8 speed at turn start! (now ${character.getEffectiveSpeed()})`, `super-effective ${teamClass}`);
                }
            }

            showHealingAnimation(targetCharacter, healAmount) {
                const teamPrefix = targetCharacter.isPlayer ? 'player' : 'enemy';
                const targetElement = document.querySelector(`[data-battle-char="${targetCharacter.id}"][data-team="${teamPrefix}"]`);
                if (!targetElement) return;
                
                // Create healing number element
                const healNum = document.createElement('div');
                healNum.className = 'damage-number damage-animation';
                healNum.style.color = '#66bb6a';
                healNum.textContent = `+${healAmount}`;
                
                const rect = targetElement.getBoundingClientRect();
                healNum.style.position = 'fixed';
                healNum.style.left = (rect.left + rect.width / 2) + 'px';
                healNum.style.top = rect.top + 'px';
                healNum.style.zIndex = '1000';
                
                document.body.appendChild(healNum);
                
                setTimeout(() => {
                    if (healNum.parentNode) {
                        healNum.remove();
                    }
                }, 2500);
            }
        }

        class BreedingGame {
            constructor() {
                this.characters = this.generateCharacters();
                this.selectedCharacters = [];
                this.botActive = false;
                this.speedMultiplier = 1;
                this.botInterval = null;
                this.victoryShown = false;
                this.selectedBattleTeam = [];
                this.battleSystem = new BattleSystem(this);
                this.init();
            }

            unlockAllCharacters() {
                Object.values(this.characters).forEach(character => {
                    if (!character.unlocked) {
                        character.unlocked = true;
                    }
                });
                
                // Recreate the table to update all slots
                this.createTable();
                this.updateDisplay();
                this.updateBattleTeamSelection();
                
                // Show victory message
                this.victoryShown = true;
                setTimeout(() => this.showVictory(), 500);
            }

            generateCharacters() {
                const characters = {};
                
                // Single gene characters (unlocked by default)
                GENES.forEach(gene => {
                    characters[gene] = new GameCharacter(gene, [gene], true);
                });

                // Double gene characters (locked by default)
                GENES.forEach((primary, i) => {
                    GENES.forEach((secondary, j) => {
                        const id = `${primary}-${secondary}`;
                        characters[id] = new GameCharacter(id, [primary, secondary], false);
                    });
                });

                return characters;
            }

            init() {
                this.setupTabNavigation();
                this.createTable();
                this.updateDisplay();
                this.setupEventListeners();
                this.updateBattleTeamSelection();
            }

            setupTabNavigation() {
                const tabButtons = document.querySelectorAll('.tab-button');
                const tabContents = document.querySelectorAll('.tab-content');
                
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const targetTab = button.dataset.tab;
                        
                        // Update active tab button
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                        
                        // Update active tab content
                        tabContents.forEach(content => {
                            if (content.id === `${targetTab}-tab`) {
                                content.classList.add('active');
                            } else {
                                content.classList.remove('active');
                            }
                        });
                        
                        // Update battle team selection when switching to battle tab
                        if (targetTab === 'battle') {
                            this.updateBattleTeamSelection();
                        }
                    });
                });
            }

            createTable() {
                const table = document.getElementById('breedingTable');
                table.innerHTML = '';

                // Create 7x6 grid: 6 columns for double genes + 1 column for singles
                for (let row = 0; row < 6; row++) {
                    // Double gene slots (6 columns)
                    for (let col = 0; col < 6; col++) {
                        const primary = GENES[col];
                        const secondary = GENES[row];
                        const id = `${primary}-${secondary}`;
                        this.createCharacterSlot(table, id);
                    }
                    
                    // Single gene slot (7th column)
                    const singleGene = GENES[row];
                    this.createCharacterSlot(table, singleGene);
                }
            }

            createCharacterSlot(container, characterId) {
                const character = this.characters[characterId];
                const slot = document.createElement('div');
                slot.className = `character-slot ${character.unlocked ? 'unlocked' : 'locked'}`;
                slot.dataset.characterId = characterId;

                const sprite = document.createElement('div');
                sprite.className = 'character-sprite';
                
                this.updateCharacterSprite(sprite, character);

                slot.appendChild(sprite);
                container.appendChild(slot);

                if (character.unlocked) {
                    slot.addEventListener('click', () => this.selectCharacter(characterId));
                }
            }

            updateCharacterSprite(sprite, character) {
                if (character.unlocked) {
                    if (character.genes.length === 1) {
                        sprite.className = sprite.className.replace(/single-gene|double-gene|same-gene|different-genes|locked-sprite/g, '').trim();
                        sprite.className += ' single-gene';
                        sprite.style.setProperty('--gene-color', GENE_COLORS[character.genes[0]]);
                        sprite.textContent = character.symbol;
                        sprite.innerHTML = character.symbol;
                    } else {
                        sprite.className = sprite.className.replace(/single-gene|double-gene|same-gene|different-genes|locked-sprite/g, '').trim();
                        sprite.className += ' double-gene';
                        
                        const isSameGene = character.genes[0] === character.genes[1];
                        if (isSameGene) {
                            sprite.classList.add('same-gene');
                            const geneColor = GENE_COLORS[character.genes[0]];
                            const darkColor = GENE_DARK_COLORS[character.genes[0]];
                            sprite.style.setProperty('--same-gene-gradient', 
                                `linear-gradient(45deg, ${geneColor}, ${darkColor}, ${geneColor})`);
                        } else {
                            sprite.classList.add('different-genes');
                            sprite.style.setProperty('--primary-color', GENE_COLORS[character.genes[0]]);
                            sprite.style.setProperty('--secondary-color', GENE_COLORS[character.genes[1]]);
                        }
                        
                        sprite.innerHTML = '';
                        const emoji1 = document.createElement('span');
                        emoji1.className = 'gene-emoji';
                        emoji1.textContent = GENE_SYMBOLS[character.genes[0]];
                        
                        const emoji2 = document.createElement('span');
                        emoji2.className = 'gene-emoji';
                        emoji2.textContent = GENE_SYMBOLS[character.genes[1]];
                        
                        sprite.appendChild(emoji1);
                        sprite.appendChild(emoji2);
                    }
                } else {
                    sprite.className = sprite.className.replace(/single-gene|double-gene|same-gene|different-genes/g, '').trim();
                    sprite.className += ' locked-sprite';
                    sprite.textContent = '?';
                    sprite.innerHTML = '?';
                    sprite.style.removeProperty('--gene-color');
                    sprite.style.removeProperty('--primary-color');
                    sprite.style.removeProperty('--secondary-color');
                    sprite.style.removeProperty('--same-gene-gradient');
                }
            }

            selectCharacter(characterId) {
                const character = this.characters[characterId];
                if (!character.unlocked || this.botActive) return;

                if (this.selectedCharacters.includes(characterId)) {
                    this.selectedCharacters = this.selectedCharacters.filter(id => id !== characterId);
                } else if (this.selectedCharacters.length < 2) {
                    this.selectedCharacters.push(characterId);
                } else {
                    this.selectedCharacters[0] = this.selectedCharacters[1];
                    this.selectedCharacters[1] = characterId;
                }

                this.updateDisplay();
            }

            updateDisplay() {
                // Update character slot selection states
                document.querySelectorAll('.character-slot').forEach(slot => {
                    const characterId = slot.dataset.characterId;
                    if (this.selectedCharacters.includes(characterId)) {
                        slot.classList.add('selected');
                    } else {
                        slot.classList.remove('selected');
                    }
                });

                // Update parent displays
                this.updateParentDisplay('parent1Display', this.selectedCharacters[0]);
                this.updateParentDisplay('parent2Display', this.selectedCharacters[1]);

                // Update breed button
                const breedBtn = document.getElementById('breedBtn');
                if (this.botActive) {
                    breedBtn.disabled = true;
                    breedBtn.textContent = 'Bot is in Control';
                } else if (this.selectedCharacters.length === 2) {
                    breedBtn.disabled = false;
                    breedBtn.textContent = 'Breed Creatures';
                } else {
                    breedBtn.disabled = true;
                    breedBtn.textContent = 'Select Two Creatures to Breed';
                }

                // Update progress
                const unlockedCount = Object.values(this.characters).filter(c => c.unlocked).length;
                const totalCount = Object.keys(this.characters).length;
                const progress = (unlockedCount / totalCount) * 100;
                
                document.getElementById('progressFill').style.width = `${progress}%`;
                document.getElementById('unlockedCount').textContent = unlockedCount;

                // Check for victory
                if (unlockedCount === totalCount && !this.victoryShown) {
                    this.victoryShown = true;
                    setTimeout(() => this.showVictory(), 1000);
                }
            }

            updateParentDisplay(displayId, characterId) {
                const display = document.getElementById(displayId);
                const sprite = display.querySelector('.character-sprite');
                
                if (characterId && this.characters[characterId]) {
                    const character = this.characters[characterId];
                    this.updateCharacterSprite(sprite, character);
                } else {
                    sprite.textContent = '?';
                    sprite.innerHTML = '?';
                    sprite.className = 'character-sprite locked-sprite';
                    sprite.style.removeProperty('--gene-color');
                    sprite.style.removeProperty('--primary-color');
                    sprite.style.removeProperty('--secondary-color');
                    sprite.style.removeProperty('--same-gene-gradient');
                }
            }

            updateBattleTeamSelection() {
                const selectionGrid = document.getElementById('battleCharacterSelection');
                const selectedTeamDisplay = document.getElementById('selectedTeamDisplay');
                const startBattleBtn = document.getElementById('startBattleBtn');
                
                if (!selectionGrid) return;
                
                // Clear existing content
                selectionGrid.innerHTML = '';
                
                // Add unlocked characters to selection
                const unlockedChars = Object.values(this.characters).filter(char => char.unlocked);
                unlockedChars.forEach(character => {
                    const slot = document.createElement('div');
                    slot.className = 'selection-slot';
                    if (this.selectedBattleTeam.includes(character.id)) {
                        slot.classList.add('selected');
                    }
                    
                    const sprite = document.createElement('div');
                    sprite.className = 'character-sprite';
                    this.updateCharacterSprite(sprite, character);
                    
                    slot.appendChild(sprite);
                    slot.addEventListener('click', () => this.toggleBattleTeamSelection(character.id));
                    selectionGrid.appendChild(slot);
                });
                
                // Update selected team display
                selectedTeamDisplay.innerHTML = '';
                this.selectedBattleTeam.forEach(charId => {
                    const character = this.characters[charId];
                    const slot = document.createElement('div');
                    slot.className = 'character-slot unlocked';
                    
                    const sprite = document.createElement('div');
                    sprite.className = 'character-sprite';
                    this.updateCharacterSprite(sprite, character);
                    
                    slot.appendChild(sprite);
                    selectedTeamDisplay.appendChild(slot);
                });
                
                // Add empty slots
                for (let i = this.selectedBattleTeam.length; i < 3; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'character-slot locked';
                    const sprite = document.createElement('div');
                    sprite.className = 'character-sprite locked-sprite';
                    sprite.textContent = '?';
                    slot.appendChild(sprite);
                    selectedTeamDisplay.appendChild(slot);
                }
                
                // Update start battle button
                if (this.selectedBattleTeam.length === 3) {
                    startBattleBtn.disabled = false;
                    startBattleBtn.textContent = 'Start Battle!';
                } else {
                    startBattleBtn.disabled = true;
                    startBattleBtn.textContent = `Select ${3 - this.selectedBattleTeam.length} more creature${3 - this.selectedBattleTeam.length !== 1 ? 's' : ''} to Start Battle`;
                }
            }

            toggleBattleTeamSelection(characterId) {
                if (this.selectedBattleTeam.includes(characterId)) {
                    this.selectedBattleTeam = this.selectedBattleTeam.filter(id => id !== characterId);
                } else if (this.selectedBattleTeam.length < 3) {
                    this.selectedBattleTeam.push(characterId);
                }
                
                this.updateBattleTeamSelection();
            }

            selectRandomTeam() {
                // Get all unlocked characters
                const unlockedCharacters = Object.values(this.characters).filter(char => char.unlocked);
                
                if (unlockedCharacters.length < 3) {
                    alert('You need at least 3 unlocked characters to use random selection!');
                    return;
                }
                
                // Clear current selection
                this.selectedBattleTeam = [];
                
                // Randomly select 3 different characters
                const shuffled = [...unlockedCharacters].sort(() => 0.5 - Math.random());
                this.selectedBattleTeam = shuffled.slice(0, 3).map(char => char.id);
                
                this.updateBattleTeamSelection();
            }

            startBattle() {
                if (this.selectedBattleTeam.length !== 3) return;
                
                // Difficulty is already set via the buttons, so just start the battle
                const playerTeam = this.selectedBattleTeam.map(id => this.characters[id]);
                this.battleSystem.setupBattle(playerTeam);
            }

            breed() {
                if (this.selectedCharacters.length !== 2) return;

                const parent1 = this.characters[this.selectedCharacters[0]];
                const parent2 = this.characters[this.selectedCharacters[1]];

                const possibleOffspring = this.getPossibleOffspring(parent1, parent2);
                const lockedOffspring = possibleOffspring.filter(id => !this.characters[id].unlocked);

                this.startBreedingAnimation(possibleOffspring, lockedOffspring);
            }

            startBreedingAnimation(possibleOffspring, lockedOffspring) {
                const breedBtn = document.getElementById('breedBtn');
                const preview = document.getElementById('breedingPreview');
                const previewChar = document.getElementById('previewCharacter');
                
                const actualResult = lockedOffspring.length > 0 ? 
                    lockedOffspring[Math.floor(Math.random() * lockedOffspring.length)] : 
                    possibleOffspring[Math.floor(Math.random() * possibleOffspring.length)];
                
                breedBtn.disabled = true;
                breedBtn.classList.add('breeding');
                breedBtn.textContent = 'Breeding...';
                
                preview.classList.add('show');
                
                let animationStep = 0;
                const totalSteps = Math.floor(20 / this.speedMultiplier);
                const animationSpeed = Math.floor(150 / this.speedMultiplier);
                
                const animationInterval = setInterval(() => {
                    let displayCharacter;
                    if (animationStep < totalSteps - 3) {
                        const randomOffspring = possibleOffspring[Math.floor(Math.random() * possibleOffspring.length)];
                        displayCharacter = this.characters[randomOffspring];
                    } else {
                        displayCharacter = this.characters[actualResult];
                    }
                    
                    this.updatePreviewCharacter(previewChar, displayCharacter);
                    this.createBreedingSparkles(previewChar, this.speedMultiplier > 1);
                    
                    animationStep++;
                    
                    if (animationStep >= totalSteps) {
                        clearInterval(animationInterval);
                        this.showFinalResult(actualResult, lockedOffspring);
                    }
                }, animationSpeed);
            }

            updatePreviewCharacter(previewChar, character) {
                previewChar.className = 'preview-character';
                
                if (character.genes.length === 1) {
                    previewChar.className += ' single-gene';
                    previewChar.style.setProperty('--gene-color', GENE_COLORS[character.genes[0]]);
                    previewChar.textContent = character.symbol;
                    previewChar.innerHTML = character.symbol;
                } else {
                    const isSameGene = character.genes[0] === character.genes[1];
                    previewChar.className += ' double-gene';
                    
                    if (isSameGene) {
                        previewChar.classList.add('same-gene');
                        const geneColor = GENE_COLORS[character.genes[0]];
                        const darkColor = GENE_DARK_COLORS[character.genes[0]];
                        previewChar.style.setProperty('--same-gene-gradient', 
                            `linear-gradient(45deg, ${geneColor}, ${darkColor}, ${geneColor})`);
                    } else {
                        previewChar.classList.add('different-genes');
                        previewChar.style.setProperty('--primary-color', GENE_COLORS[character.genes[0]]);
                        previewChar.style.setProperty('--secondary-color', GENE_COLORS[character.genes[1]]);
                    }
                    
                    previewChar.innerHTML = '';
                    const emoji1 = document.createElement('span');
                    emoji1.className = 'gene-emoji';
                    emoji1.textContent = GENE_SYMBOLS[character.genes[0]];
                    
                    const emoji2 = document.createElement('span');
                    emoji2.className = 'gene-emoji';
                    emoji2.textContent = GENE_SYMBOLS[character.genes[1]];
                    
                    previewChar.appendChild(emoji1);
                    previewChar.appendChild(emoji2);
                }
            }

            showFinalResult(actualResult, lockedOffspring) {
                const previewChar = document.getElementById('previewCharacter');
                const resultCharacter = this.characters[actualResult];
                
                const sunshine = document.createElement('div');
                sunshine.className = 'sunshine-effect';
                previewChar.appendChild(sunshine);
                
                this.updatePreviewCharacter(previewChar, resultCharacter);
                
                setTimeout(() => {
                    sunshine.remove();
                    this.finishBreeding(lockedOffspring, actualResult);
                }, Math.floor(2000 / this.speedMultiplier));
            }

            createBreedingSparkles(container, isFastMode = false) {
                const sparkleCount = isFastMode ? 3 : 5;
                const duration = isFastMode ? Math.floor(400 / this.speedMultiplier) : Math.floor(800 / this.speedMultiplier);
                
                for (let i = 0; i < sparkleCount; i++) {
                    setTimeout(() => {
                        const sparkle = document.createElement('div');
                        sparkle.className = 'breeding-sparkle';
                        
                        const angle = (Math.PI * 2 * i) / sparkleCount;
                        const radius = 60 + Math.random() * 20;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        
                        sparkle.style.left = `${50 + (x / 150) * 100}%`;
                        sparkle.style.top = `${50 + (y / 150) * 100}%`;
                        sparkle.style.background = `hsl(${Math.random() * 360}, 100%, 80%)`;
                        
                        container.appendChild(sparkle);
                        
                        const animation = sparkle.animate([
                            { transform: 'scale(0) rotate(0deg)', opacity: 1 },
                            { transform: 'scale(1) rotate(180deg)', opacity: 1, offset: 0.5 },
                            { transform: 'scale(0) rotate(360deg)', opacity: 0 }
                        ], {
                            duration: duration,
                            easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                        });
                        
                        animation.onfinish = () => sparkle.remove();
                    }, i * Math.floor((isFastMode ? 25 : 50) / this.speedMultiplier));
                }
            }

            finishBreeding(lockedOffspring, actualResult) {
                const breedBtn = document.getElementById('breedBtn');
                const preview = document.getElementById('breedingPreview');
                
                setTimeout(() => {
                    preview.classList.remove('show');
                    
                    if (lockedOffspring.length > 0 && actualResult) {
                        this.unlockCharacter(actualResult);
                        this.createParticleEffect();
                    }

                    breedBtn.classList.remove('breeding');
                    breedBtn.disabled = false;
                    
                    this.selectedCharacters = [];
                    this.updateDisplay();
                }, 500);
            }

            getPossibleOffspring(parent1, parent2) {
                const offspring = [];
                
                parent1.genes.forEach(gene1 => {
                    parent2.genes.forEach(gene2 => {
                        const combo1 = `${gene1}-${gene2}`;
                        const combo2 = `${gene2}-${gene1}`;
                        
                        if (!offspring.includes(combo1)) {
                            offspring.push(combo1);
                        }
                        if (!offspring.includes(combo2) && combo1 !== combo2) {
                            offspring.push(combo2);
                        }
                    });
                });

                return offspring;
            }

            unlockCharacter(characterId) {
                this.characters[characterId].unlocked = true;
                
                const slot = document.querySelector(`[data-character-id="${characterId}"]`);
                if (slot) {
                    slot.classList.remove('locked');
                    slot.classList.add('unlocked', 'new-discovery');
                    
                    const sprite = slot.querySelector('.character-sprite');
                    const character = this.characters[characterId];
                    
                    this.updateCharacterSprite(sprite, character);

                    slot.addEventListener('click', () => this.selectCharacter(characterId));
                    setTimeout(() => slot.classList.remove('new-discovery'), 800);
                }
            }

            createParticleEffect() {
                const colors = ['#ff6b6b', '#4ecdc4', '#ffe66d', '#a8e6cf', '#ff8b94', '#b4a7d6'];
                
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = 'particle';
                        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                        particle.style.left = Math.random() * window.innerWidth + 'px';
                        particle.style.top = Math.random() * window.innerHeight + 'px';

                        document.body.appendChild(particle);

                        const animation = particle.animate([
                            { transform: 'translateY(0px) scale(1)', opacity: 1 },
                            { transform: 'translateY(-100px) scale(0)', opacity: 0 }
                        ], {
                            duration: 2000,
                            easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                        });

                        animation.onfinish = () => particle.remove();
                    }, i * 50);
                }
            }

            showVictory() {
                const victoryMessage = document.getElementById('victoryMessage');
                victoryMessage.classList.add('show');
                
                // Auto-hide after 2 seconds
                setTimeout(() => {
                    victoryMessage.classList.remove('show');
                }, 2000);
            }

            setupEventListeners() {
                document.getElementById('breedBtn').addEventListener('click', () => this.breed());
                document.getElementById('botToggle').addEventListener('change', (e) => this.toggleBot(e.target.checked));
                document.getElementById('resetButton').addEventListener('click', () => this.showResetConfirmation());
                document.getElementById('confirmReset').addEventListener('click', () => this.confirmReset());
                document.getElementById('cancelReset').addEventListener('click', () => this.cancelReset());
                document.getElementById('startBattleBtn').addEventListener('click', () => this.startBattle());
                document.getElementById('unlockAllBtn').addEventListener('click', () => this.unlockAllCharacters());
                document.getElementById('randomSelectBtn').addEventListener('click', () => this.selectRandomTeam());

                // Add this to setupEventListeners method
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        e.target.closest('.difficulty-btn').classList.add('active');
                        const difficulty = e.target.closest('.difficulty-btn').dataset.difficulty;
                        this.battleSystem.setDifficulty(difficulty);
                    });
                });
                
                // Speed control listeners
                document.querySelectorAll('.speed-radio').forEach(radio => {
                    radio.addEventListener('click', (e) => {
                        const speed = parseInt(e.target.dataset.speed);
                        this.setSpeed(speed);
                    });
                });
            }

            showResetConfirmation() {
                document.getElementById('confirmationPopup').classList.add('show');
            }

            confirmReset() {
                document.getElementById('confirmationPopup').classList.remove('show');
                this.resetGame();
            }

            cancelReset() {
                document.getElementById('confirmationPopup').classList.remove('show');
            }

            setSpeed(multiplier) {
                this.speedMultiplier = multiplier;
                
                // Update UI
                document.querySelectorAll('.speed-radio').forEach(radio => {
                    radio.classList.remove('active');
                });
                document.querySelector(`[data-speed="${multiplier}"]`).classList.add('active');
            }

            resetGame() {
                this.stopBotSolver();
                
                // Reset victory flag and hide message properly
                this.victoryShown = false;
                const victoryMessage = document.getElementById('victoryMessage');
                victoryMessage.classList.remove('show');
                
                this.characters = this.generateCharacters();
                this.selectedCharacters = [];
                this.selectedBattleTeam = [];
                this.botActive = false;
                this.speedMultiplier = 1;
                this.battleSystem = new BattleSystem(this);
                
                document.getElementById('botToggle').checked = false;
                document.getElementById('botStatus').textContent = 'Bot is off - You\'re in control';
                document.getElementById('botStatus').classList.remove('active');
                
                // Reset speed controls
                document.querySelectorAll('.speed-radio').forEach(radio => {
                    radio.classList.remove('active');
                });
                document.querySelector('[data-speed="1"]').classList.add('active');
                
                // Return to breeding tab
                document.querySelector('[data-tab="breeding"]').click();
                
                this.createTable();
                this.updateDisplay();
                this.updateBattleTeamSelection();
            }

            toggleBot(active) {
                this.botActive = active;
                const status = document.getElementById('botStatus');
                
                if (active) {
                    status.textContent = 'Bot is solving - Sit back and watch!';
                    status.classList.add('active');
                    this.startBotSolver();
                } else {
                    status.textContent = 'Bot is off - You\'re in control';
                    status.classList.remove('active');
                    this.stopBotSolver();
                }
            }

            startBotSolver() {
                if (this.botInterval) return;
                
                this.botInterval = setInterval(() => {
                    if (!this.botActive) return;
                    
                    const bestPair = this.findBestBreedingPair();
                    if (bestPair) {
                        this.selectedCharacters = bestPair;
                        this.updateDisplay();
                        
                        setTimeout(() => {
                            if (this.botActive) {
                                this.breed();
                            }
                        }, 1000);
                    }
                }, 4000);
            }

            stopBotSolver() {
                if (this.botInterval) {
                    clearInterval(this.botInterval);
                    this.botInterval = null;
                }
                this.selectedCharacters = [];
                this.updateDisplay();
            }

            findBestBreedingPair() {
                const unlockedCharacters = Object.keys(this.characters).filter(id => this.characters[id].unlocked);
                const lockedCharacters = Object.keys(this.characters).filter(id => !this.characters[id].unlocked);
                
                if (lockedCharacters.length === 0) return null;
                
                let bestPair = null;
                let maxPotentialUnlocks = 0;
                
                for (let i = 0; i < unlockedCharacters.length; i++) {
                    for (let j = i; j < unlockedCharacters.length; j++) {
                        const char1 = this.characters[unlockedCharacters[i]];
                        const char2 = this.characters[unlockedCharacters[j]];
                        
                        const offspring = this.getPossibleOffspring(char1, char2);
                        const potentialUnlocks = offspring.filter(id => !this.characters[id].unlocked).length;
                        
                        if (potentialUnlocks > maxPotentialUnlocks) {
                            maxPotentialUnlocks = potentialUnlocks;
                            bestPair = [unlockedCharacters[i], unlockedCharacters[j]];
                        }
                    }
                }
                
                return bestPair;
            }
        }

        // Start the game
        new BreedingGame();
    </script>
</body>
</html>